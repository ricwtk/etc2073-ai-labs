{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"ETC2073 Artificial Intelligence <p>This site hosts the lab sheets for the module of ETC2073 Artificial Intelligence in the Department of Engineering (DEN) in Sunway University.</p>"},{"location":"#aim","title":"Aim","text":"<p>The aim of these labs is to guide the students to implement the basic artificial intelligence (AI) algorithms with and/or without Python libraries.</p>"},{"location":"#information","title":"Information","text":"<p>The labs are designed to follow the schedule of the lectures, therefore you will require the knowledge of the previous lectures to be able to conduct the lab.</p>"},{"location":"#schedule","title":"Schedule","text":"<p>The schedule is subject to change.</p> Session 1 Getting started Session 2 Lab 1 Introductory Python Session 3 Lab 2 Fuzzy Systems Session 4 Lab 3 Uninformed Search Algorithm Session 5 Lab 3 Genetic Algorithm Session 6 Lab 4 Machine Learning"},{"location":"get-start/","title":"Getting started","text":"<p>The labs for ETC2073 Artificial Intelligence will be using Python as the programming language. The Anaconda distribution of Python is recommended, however, if you are familiar and comfortable with the vanilla distribution of Python. For those who have not installed Python in their machine, proceed to next session. This page only covers the installation of the Anaconda platform as, in my opinion, it is more beginner friendly in terms of installing packages and encapsulating environments.</p>"},{"location":"get-start/#installation","title":"Installation","text":"<ol> <li> <p>Download the Anaconda installer with Python 3 for your system from https://www.anaconda.com/download.</p> </li> <li> <p>Use the graphical installer to install Anaconda.</p> </li> </ol>"},{"location":"get-start/#launching-ide","title":"Launching IDE","text":"<p>You will be using the Spyder IDE for Python. Feel free to use other IDE or code editor with terminal if that's your preference.</p> <ol> <li> <p>Start the Anaconda Navigator from your application list.</p> </li> <li> <p>From Anaconda <code>base</code> environment, launch Spyder IDE.</p> </li> <li> <p>The Spyder IDE consists of three parts: the editor, the variable explorer, and the IPython Console.</p> </li> <li> <p>The editor is where you write your codes.</p> </li> <li> <p>The variable explorer shows the value of the variable after running the code.</p> </li> <li> <p>The IPython console allows you to execute commands, interact with the running code, and display visualisation.</p> </li> <li> <p>After the code is written in the editor, you can execute the code using F5 to run file.</p> </li> <li> <p>Then the variables and their values can be found in the variable explorer.</p> </li> </ol>"},{"location":"lab1-introductory-python/","title":"Lab 1: Introduction to Python","text":""},{"location":"lab1-introductory-python/#objective","title":"Objective","text":"<p>To understand basic syntax of Python programming language.</p>"},{"location":"lab1-introductory-python/#declare-a-variable","title":"Declare a variable","text":"<p>Python is strongly and dynamically typed.</p> <p>Strongly typed means the type of a variable does not change unexpectedly. When a variable is defined as a string with only numerical digits, it stays string, it doesn\u2019t become an integer or number.</p> <p>Dynamically typed means the type of a variable can change when a value of a different type is assigned to the variable.</p> <p>As Python is dynamically typed, we do not need to specify a type when we declare a variable. We just assign a value to the variable.</p> <ol> <li> <p>Define a variable named <code>val</code> and assign the value <code>'a'</code> to the variable.</p> <pre><code>val = 'a'\n</code></pre> <p>The type of the variable can be viewed in the variable explorer.</p> </li> <li> <p>Continue from the previous code block, assign the value <code>1</code> to the same variable. The variable will now be of type <code>int</code> instead of type <code>str</code>.</p> <pre><code>val = 1\n</code></pre> </li> </ol>"},{"location":"lab1-introductory-python/#array-manipulation","title":"Array manipulation","text":"<ol> <li> <p>Array in Python can be declared using a set of square brackets (<code>[...]</code>).</p> </li> <li> <p>To assign a variable with an empty array,</p> <pre><code>arr = []\n</code></pre> </li> <li> <p>To define an array with a series of numbers,</p> <pre><code>arr = [1,2,3,4,5]\n</code></pre> </li> <li> <p>To define an array with a series of alphabets,</p> <pre><code>arr = ['a','b','c','d','e']\n</code></pre> </li> <li> <p>An array can also be defined with values of mixed types.</p> <pre><code>arr = [1,'a',2,'b',3,'c']\n</code></pre> </li> <li> <p>Python arrays (or more commonly known as lists) are zero indexed arrays; it means to access the first element in the array <code>arr</code>,</p> <pre><code># in IPython console\narr[0] # gives the output of 1\narr[1] # gives the output of 'a'\n</code></pre> </li> <li> <p>Python arrays also support negative indexing; this means to get the last element in the array <code>arr</code>,</p> <pre><code># in IPython console\narr[-1] # gives the output of 'c'\n</code></pre> </li> <li> <p>Colon (<code>:</code>) can be used to extract multiple elements from an array. Maximum two (2) colons can be used for indexing/slicing an array. <code>arr[0:5:2]</code> The value before the first colon is the starting index, the value after the first colon is the ending index (exclusive), the value after the second colon is the number of steps. </p> <p>If the first value is empty, it is assumed as <code>0</code>.</p> <p>If the second value is empty, it is assumed as the length of the array, i.e. up till the last element in the array.</p> <p>If the third value is empty, it is assumed as <code>1</code>.</p> <pre><code># in IPython console\narr\n# [1, 'a', 2, 'b', 3, 'c']\narr[1:5]\n# ['a', 2, 'b', 3]\narr[1:5:2]\n# ['a', 'b']\narr[:3]\n# [1, 'a', 2]\narr[4:]\n# [3, 'c']\narr[2:-2]\n# [2, 'b']\narr[4:1]\n# []\narr[4:1:-1]\n# [3, 'b', 2] --&gt; slice in the reverse order\n</code></pre> </li> </ol>"},{"location":"lab1-introductory-python/#add-an-element-to-the-end-of-an-array","title":"Add an element to the end of an array","text":"<pre><code># in IPython console\narr.append(4)\narr\n# [1, 'a', 2, 'b', 3, 'c', 4]\n</code></pre>"},{"location":"lab1-introductory-python/#add-multiple-elements-to-the-end-of-an-array","title":"Add multiple elements to the end of an array","text":"<pre><code># in IPython console\narr.extend(['d',5,'e'])\narr\n# [1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n</code></pre>"},{"location":"lab1-introductory-python/#assign-a-value-to-a-specific-index","title":"Assign a value to a specific index","text":"<pre><code># in IPython console\narr[0] = 0\narr\n# [0, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n</code></pre>"},{"location":"lab1-introductory-python/#insert-an-element-at-a-specific-index","title":"Insert an element at a specific index","text":"<pre><code># in IPython console\narr.insert(1,1)\narr\n# [0, 1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n</code></pre>"},{"location":"lab1-introductory-python/#remove-an-element-at-a-specific-index","title":"Remove an element at a specific index","text":"<pre><code># in IPython console\ndel arr[0]\narr\n# [1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n</code></pre>"},{"location":"lab1-introductory-python/#combining-arrays","title":"Combining arrays","text":"<p><code>zip</code> can be used to combine two or more arrays.</p> <pre><code># in editor\njoint_arr = list(zip([1,2,3], ['a','b','c']))\n</code></pre> <pre><code># in IPython console\njoint_arr\n# [(1,'a'),(2,'b'),(3,'c')]\n</code></pre>"},{"location":"lab1-introductory-python/#loops","title":"Loops","text":"<ol> <li> <p>Python supports <code>for</code> and <code>while</code> loops.</p> </li> <li> <p>To loop through every element in the array <code>arr</code> and print them to the console,</p> <pre><code>for a in arr:\n  print(a)\n# 1\n# a\n# 2\n# ...\n</code></pre> <p><code>for a in arr</code>: loops through all elements in <code>arr</code> and in each loop, an element in <code>arr</code> is assigned to the variable <code>a</code>.</p> </li> <li> <p>Note that in most other programming languages, code blocks are separated with delimiters such as the curly brackets (<code>{}</code>). This is not the case in Python. Code blocks in Python are defined by their indentation and normally initiated with a colon(<code>:</code>). </p> <p>For example,</p> <pre><code>for a in arr:\n  print(a)\nprint(arr)\n</code></pre> <p><code>print(a)</code> is the command to be executed in each loop.</p> <p><code>print(arr)</code> is only executed after the <code>for</code> loop is completed.</p> <pre><code>for a in arr:\n  print(a)\n  print(arr)\n</code></pre> <p>In this case, <code>print(arr)</code> is executed in each loop.</p> </li> <li> <p>Using <code>zip</code> we can loop through two arrays at once.</p> <pre><code>for item in zip(['a','b','c','d'],['artificial','breadth','cost','depth']):\n  print(item[0] + ' for ' + item[1])\n</code></pre> </li> <li> <p><code>enumerate</code> is useful in obtaining the index of the element in the array.</p> <pre><code>for (index, item) in enumerate(['a','b','c','d']):\n  print('Index of ' + item + ' is: ' + str(index))\n</code></pre> </li> <li> <p>Looping through a dictionary (<code>dict</code>) can also be done easily.</p> <pre><code>x_dict = {\n  'd': 'depth',\n  'e': 'estimation',\n  'f': 'frontier'\n}\nfor key,value in x_dict.items():\n  print(key + ' for ' + value)\n</code></pre> </li> <li> <p><code>while</code> loops can be defined similarly.</p> <pre><code>x = 0\nwhile x != 10: \n  x += 1\n  print(x)\nprint('while loop is completed')\n</code></pre> </li> <li> <p>The following example introduces nested array and multiple assignments.</p> <pre><code>arr = [['a',1],['b',2],['c',3],['d',4],['e',5],['f',6]]\nfor [a,n] in arr:\n  print(str(a) + ' is ' + str(n))\n</code></pre> </li> </ol>"},{"location":"lab1-introductory-python/#conditions","title":"Conditions","text":"<ol> <li> <p>The following operators can be used for conditional testing:</p> Operator Definition <code>==</code> Equivalence <code>!=</code> Inequivalence <code>&lt;</code> Less than <code>&lt;=</code> Less than or equal to <code>&gt;</code> Greater than <code>&gt;=</code> Greater than or equal to </li> <li> <p>Python also supports text operator for conditional testing:</p> Operator Definition Example (symbolic) Example (text) <code>is</code> Equivalence <code>a == 1</code> <code>a is 1</code> <code>not</code> Inequivalence <code>a != 1</code> <code>a is not 1</code>  or <code>not (a is 1)</code>  or <code>not a is 1</code>  or <code>not(a == 1)</code> </li> <li> <p>Combining two conditions can also be done with text operators <code>and</code> and <code>or</code>.</p> Symbolic operator Text operator <code>&amp;</code> <code>and</code> <code>|</code> <code>or</code> </li> </ol>"},{"location":"lab1-introductory-python/#user-defined-functions","title":"User-defined functions","text":"<ol> <li> <p>To define a custom function with the name of <code>custom_fcn</code>,</p> <pre><code>def custom_fcn():\n  print('This is a custom function to display custom message')\n</code></pre> </li> <li> <p>To call the function,</p> <pre><code>custom_fcn()\n# This is a custom function to display custom message\n</code></pre> </li> </ol>"},{"location":"lab1-introductory-python/#user-defined-functions-with-input-arguments","title":"User-defined functions with input arguments","text":"<ol> <li> <p>To define a custom function with input arguments,</p> <pre><code>def custom_fcn(msg):\n  print('This is a custom function to display ' + msg)\n</code></pre> </li> <li> <p>The function can be called by</p> <pre><code>custom_fcn('new message')\n# This is a custom function to display new message\n</code></pre> </li> </ol>"},{"location":"lab1-introductory-python/#user-defined-functions-with-optional-input-arguments","title":"User-defined functions with optional input arguments","text":"<ol> <li> <p>To define a custom function with optional input arguments, we just need to provide the default value to the optional input arguments.</p> <pre><code>def custom_fcn(msg = 'default message'):\n  print('This is a custom function to display ' + msg)\n</code></pre> </li> <li> <p>The input arguments can also be specified as named inputs.</p> <pre><code>custom_fcn(msg='new message')\n# This is a custom function to display new message\n</code></pre> </li> </ol>"},{"location":"lab1-introductory-python/#exercise","title":"Exercise","text":"<ol> <li> <p>Create a new file in Spyder. Define a variable named <code>friends</code> such that it is a nested array in which contains the name, home country, and home state/province of 10 of your friends (real or virtual). For example,</p> <pre><code>friends = [[\"James\", \"Malaysia\", \"Malacca\"], [\"Goh\", \"Australia\", \"Brisbane\"], [\"Don\", \"Malaysia\", \"Pahang\"]]\n</code></pre> </li> <li> <p>Create a function in the same file with three (3) optional input arguments, <code>name</code>, <code>home_country</code>, <code>home_state</code>.</p> <pre><code>def filterFriend(name=\"\", home_country=\"\", home_state=\"\"):\n  ...\n  return filtered\n</code></pre> <p>This function will filter <code>friends</code> based on the input arguments provided. The function will ignore the input argument if it has empty string, i.e. <code>\"\"</code>. If any of the input arguments is provided, the function will find the friends whose detail(s) matches the input.</p> <p>For example, </p> <p><code>filterFriend(name=\"James\")</code> will return <code>[[\"James\", \"Malaysia\", \"Malacca\"]]</code></p> <p><code>filterFriend(home_country=\"Malaysia\")</code> will return <code>[[\"James\", \"Malaysia\", \"Malacca\"], [\"Don\", \"Malaysia\", \"Pahang\"]]</code>.</p> </li> </ol>"},{"location":"lab2-fuzzy/","title":"Lab 2: Fuzzy Systems","text":""},{"location":"lab2-fuzzy/#lab-learning-outcomes","title":"Lab learning outcomes","text":"<p>After completing this lab, the students are able to</p> <ul> <li>construct a Mamdani fuzzy system using the <code>scikit-fuzzy</code> Python library and</li> <li>evaluate the result of the constructed fuzzy system.</li> </ul>"},{"location":"lab2-fuzzy/#note","title":"Note","text":"<p>Install the <code>scikit-fuzzy</code> Python library in your environment before proceeding with the lab.</p> <pre><code>conda install -c conda-forge scikit-fuzzy\n</code></pre>"},{"location":"lab2-fuzzy/#fuzzy-control-system-for-a-train","title":"Fuzzy control system for a train","text":"<ol> <li> <p>Consider a fuzzy control system to control the brake and throttle of a train based on the speed of the train and the distance of the train to the next stop.</p> </li> <li> <p>Import the <code>skfuzzy</code>, <code>skfuzzy.control</code>, and <code>numpy</code>.</p> <pre><code>import numpy as np\nfrom skfuzzy import control as ctrl\nfrom skfuzzy import membership as mf\n</code></pre> </li> </ol>"},{"location":"lab2-fuzzy/#initialise-inputs-and-outputs","title":"Initialise inputs and outputs","text":"<ol> <li> <p>Speed and distance are the inputs of the system whereas brake and throttle are the outputs.</p> </li> <li> <p>The ranges for the variables are:</p> Variable Range Speed 0 - 85 km/h Distance 0 - 3000 m Brake 0 - 100% Throttle 0 - 100% </li> <li> <p>As the inputs will be the antecedents of the rules, construct the variables <code>speed</code> and <code>distance</code> as <code>skfuzzy.control.Antecedent</code> objects. </p> <pre><code>speed = ctrl.Antecedent(np.arange(0, 85, 0.1), 'speed')\n</code></pre> </li> <li> <p>The initialisation function for <code>skfuzzy.control.Antecedent</code> object takes 2 arguments, the first is the universe of the variable, i.e. the values the variables can take, the second is the label of the variable. The initialisation function for <code>skfuzzy.control.Consequent</code> is similar. </p> </li> <li> <p>The label and the range of the variable can be accessed using <code>.label</code> and <code>.universe</code> respectively.</p> </li> </ol> <p>Task: Initialise the variables <code>distance</code> as <code>Antecedent</code> object, and <code>brake</code> and <code>throttle</code> as <code>Consequent</code> objects. (Outputs of the system will be consequents of the rules)</p>"},{"location":"lab2-fuzzy/#define-membership-functions-for-fuzzy-sets-of-variables","title":"Define membership functions for fuzzy sets of variables","text":"<ol> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>speed (0 to 85 km/h)</p> Linguistic value Fit vector Stopped (1/0, 0/2) Very slow (0/1, 1/2.5, 0/4) Slow (0/2.5, 1/6.5, 0/10.5) Medium fast (0/6.5, 1/26.5, 0/46.5) Fast (0/26.5, 1/70, 1/85) </li> <li> <p>distance (0 to 3000 m)</p> Linguistic value Fit vector At (1/0, 0/2) Very near (0/1, 1/3, 0/5) Near (0/3, 1/101.5, 0/200) Medium far (0/100, 1/1550, 0/3000) Far (0/1500, 1/2250, 1/3000) </li> <li> <p>brake (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/40) Very slight (0/20, 1/50, 0/80) Slight (0/70, 1/83.5, 0/97) Medium (0/95, 1/97, 0/99) Full (0/98, 1/100) </li> <li> <p>throttle (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/2) Very slight (0/1, 1/3, 0/5) Slight (0/3, 1/16.5, 0/30) Medium (0/20, 1/50, 0/80) Full (0/60, 1/80, 1/100) </li> </ul> </li> <li> <p>The <code>skfuzzy.membership</code> module provides the following membership functions:</p> Membership function Description <code>skfuzzy.membership.dsigmf(x, b1, c1, b2, c2)</code> Difference of two fuzzy sigmoid membership functions <code>skfuzzy.membership.gauss2mf(x, mean1, ...)</code> Gaussian fuzzy membership function of two combined Gaussians <code>skfuzzy.membership.gaussmf(x, mean, sigma)</code> Gaussian fuzzy membership function <code>skfuzzy.membership.gbellmf(x, a, b, c)</code> Generalized Bell function fuzzy membership generator <code>skfuzzy.membership.piecemf(x, abc)</code> Piecewise linear membership function (particularly used in FIRE filters) <code>skfuzzy.membership.pimf(x, a, b, c, d)</code> Pi-function fuzzy membership generator <code>skfuzzy.membership.psigmf(x, b1, c1, b2, c2)</code> Product of two sigmoid membership functions <code>skfuzzy.membership.sigmf(x, b, c)</code> The basic sigmoid membership function generator <code>skfuzzy.membership.smf(x, a, b)</code> S-function fuzzy membership generator <code>skfuzzy.membership.trapmf(x, abcd)</code> Trapezoidal membership function generator <code>skfuzzy.membership.trimf(x, abc)</code> Triangular membership function generator <code>skfuzzy.membership.zmf(x, a, b)</code> Z-function fuzzy membership generator </li> <li> <p>The fit vector of a linguitic value can be assigned to a linguistic variable using</p> <pre><code>speed['stopped'] = mf.trimf(speed.universe, [0, 0, 2])\nspeed['very slow'] = mf.trimf(speed.universe, [1, 2.5, 4])\n</code></pre> <p>Task: Assign all fuzzy sets to the linguistic variables.</p> </li> <li> <p>The fuzzy set diagram of a linguistic variable can be viewed using <code>.view()</code></p> <pre><code>speed.view()\n</code></pre> <p>Task: Check if the fuzzy set diagrams match the fit vectors.</p> </li> </ol>"},{"location":"lab2-fuzzy/#define-rules","title":"Define rules","text":"<ol> <li> <p>The rules for this system are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Distance At Very near Near Medium far Far Speed Stopped Full brakeNo throttle Full brakeVery slight throttle Very slow Full brakeNo throttle Medium brakeVery slight throttle Slight brakeVery slight throttle Slow Full brakeNo throttle Medium brakeVery slight throttle Very slight brakeSlight throttle Medium fast Very slight brakeMedium throttle No brakeFull throttle Fast Very slight brakeMedium throttle No brakeFull throttle </p> </li> <li> <p>Rule can be defined using <code>skfuzzy.control.Rule(antecedent, consequent, label)</code>. To define the first rule, i.e. if distance is 'at' and speed is 'stopped', then full brake and no throttle, </p> <pre><code>rule1 = ctrl.Rule(distance['at'] &amp; speed['stopped'], (brake['full'], throttle['no']))\n</code></pre> <p>If the antecedent consists of multiple parts, they can be combined using operators <code>|</code> (OR), <code>&amp;</code> (AND), and <code>~</code> (NOT).</p> <p>If the consequent consists of multiple parts, they can be combined as a <code>list</code>/<code>tuple</code>.</p> <p>Task: Define all the rules. Then combine all the rules in a <code>list</code>, i.e. <code>rules = [rule1, rule2, ...]</code>.</p> </li> </ol>"},{"location":"lab2-fuzzy/#construct-the-fuzzy-control-system","title":"Construct the fuzzy control system","text":"<ol> <li> <p>The train control system can be constructed with</p> <pre><code>train_ctrl = ctrl.ControlSystem(rules=rules)\n</code></pre> </li> <li> <p>A <code>skfuzzy.control.ControlSystemSimulation</code> object is needed to simulate the control system to obtain the outputs given certain inputs.</p> <pre><code>train = ctrl.ControlSystemSimulation(control_system=train_ctrl)\n</code></pre> </li> <li> <p>To obtain the values for <code>brake</code> and <code>throttle</code> given that <code>speed</code> is 30 km/h and <code>distance</code> is 6 m,</p> <pre><code># define the values for the inputs\ntrain.input['speed'] = 30\ntrain.input['distance'] = 2000\n\n# compute the outputs\ntrain.compute()\n\n# print the output values\nprint(train.output)\n\n# to extract one of the outputs\nprint(train.output['brake'])\n</code></pre> </li> <li> <p>To view the results in the graph,</p> <pre><code>brake.view(sim=train)\nthrottle.view(sim=train)\n</code></pre> </li> </ol>"},{"location":"lab2-fuzzy/#view-the-controloutput-space","title":"View the control/output space","text":"<ol> <li> <p>The control/output space allows us to identify if the outputs fit our expectation.</p> </li> <li> <p>Construct an empty 3D space with 100-by-100 x-y grid.</p> <pre><code>x, y = np.meshgrid(np.linspace(speed.universe.min(), speed.universe.max(), 100),\n                   np.linspace(distance.universe.min(), distance.universe.max(), 100))\nz_brake = np.zeros_like(x, dtype=float)\nz_throttle = np.zeros_like(x, dtype=float)\n</code></pre> </li> <li> <p>Loop through every point and identify the value of brake and throttle of each point. As the specified rules are not exhaustive, i.e. some input combinations do not activate any rule, we will set the output of such input combinations to be <code>float('inf')</code>.     <pre><code>for i,r in enumerate(x):\n  for j,c in enumerate(r):\n    train.input['speed'] = x[i,j]\n    train.input['distance'] = y[i,j]\n    train.compute()\n    try:\n      z_brake[i,j] = train.output['brake']\n      z_throttle[i,j] = train.output['throttle']  \n    except:\n      z_brake[i,j] = float('inf')\n      z_throttle[i,j] = float('inf')\n</code></pre></p> </li> <li> <p>Plot the result in a 3D graph using the <code>matplotlib.pyplot</code> library.</p> <pre><code>import matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef plot3d(x,y,z):\n  fig = plt.figure()\n  ax = fig.add_subplot(111, projection='3d')\n\n  ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='viridis', linewidth=0.4, antialiased=True)\n\n  ax.contourf(x, y, z, zdir='z', offset=-2.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='x', offset=x.max()*1.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='y', offset=y.max()*1.5, cmap='viridis', alpha=0.5)\n\n  ax.view_init(30, 200)\n\nplot3d(x, y, z_brake)\nplot3d(x, y, z_throttle)\n</code></pre> </li> </ol>"},{"location":"lab2-fuzzy/#fuzzy-tipping-recommendation-system","title":"Fuzzy tipping recommendation system","text":"<ol> <li> <p>A fuzzy expert system is designed to identify the percentage of tips a customer will give based on the service and the food the customer received.</p> </li> <li> <p>The system has service rating and food rating as inputs, and tips as output.</p> </li> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>service (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>food (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>tips (0 to 30%)</p> Linguistic value Fit vector Low (1/0, 0/15) Medium (0/0, 1/15, 0/30) High (0/15, 1/30) </li> </ul> </li> <li> <p>The rules are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Food Poor Average Good Service Poor low tips low tips medium tips Average low tips medium tips high tips Good medium tips high tips high tips </p> </li> </ol> <p>Task: Construct the fuzzy inference system.</p> <p>Task: Discuss, if you were to make at least one modification to the fuzzy tipping recommendation system, what it will be and why.</p>"},{"location":"lab2-fuzzy/#report","title":"Report","text":"<p>Submit a report detailing the process, results, graphs, and your observations.</p>"},{"location":"lab3-uninformed-search/","title":"Lab 3: Breadth-First Search","text":""},{"location":"lab3-uninformed-search/#lab-learning-outcomes","title":"Lab learning outcomes","text":"<p>After completing this lab, the students are able to </p> <ul> <li>create Python script to execute breadth-first search algorithm to solve a search problem.</li> </ul>"},{"location":"lab3-uninformed-search/#nicks-route-finding-problem-in-romania","title":"Nick's route-finding problem in Romania","text":"<p>The first search problem we are focusing on is Nick\u2019s route-finding problem in Romania, starting in Arad to reach Bucharest. The road map of Romania, which is the state space of the problem is given as follows:</p> 75 71 151 140 118 111 70 75 120 146 80 99 97 138 101 211 90 85 98 86 142 92 87 Arad Zerind Oradea Sibiu Fagaras Rimnicu Vilcea Pitesti Craiova Drobeta Mehadia Lugoj Timisoara Bucharest Giurgiu Urziceni Hirsova Eforie Vaslui Iasi Neamt <p>To solve the problem, we need to define the representation of the state, determine the transition model, and the execution of the search algorithm.</p>"},{"location":"lab3-uninformed-search/#state-representation","title":"State representation","text":"<p>In this problem the only state we need to consider is the location of Nick. Therefore we can use the names of the cities as the state.</p> <p>Since Nick is starting in Arad, going to Bucharest, we can define the initial state and goal state as</p> <pre><code>initial_state = \"Arad\"\ngoal_state = \"Bucharest\"\n</code></pre>"},{"location":"lab3-uninformed-search/#transition-model-and-state-space","title":"Transition model and state space","text":"<p>The transition model provides the way to identify the child of a node in a search tree given a specific action. In this problem, we need to translate the whole state space from the geographical network into the program together with the step costs between the connected states.</p> <p>The important information from the state space is the connections between states and the step costs between connected states. Notice that in this problem the connections are reversible. Therefore in our state space the connection from Arad to Zerind and the connection from Zerind to Arad are identical, hence only one instance of that connection is needed.</p> <p>The most straightforward way of defining the state space is by using a nested array, in which each inner array consists of the two connected states and its cost. </p> <p>Define a variable <code>state_space</code> to store the state space. The following code shows the first three elements in the nested array. Complete the definition of the variable by referring to the state space provided.</p> <pre><code>state_space = [\n  ['Arad', 'Zerind', 75],\n  ['Arad', 'Timisoara', 118],\n  ['Timisoara', 'Lugoj', 111],\n  ...\n]\n</code></pre> <p>In this problem, the actions are to travel to connected cities from the current city Nick is in. The transition model is directly defined by the action. Therefore, create a function to search through the state space to find the children of a node, which would suffice as actions and transition model.</p> <p>This function loops through the <code>state_space</code> variable to check for connections linked to the current node. The state on the connection becomes the child of the node in the search tree. We define a new function called <code>expandAndReturnChildren</code>.</p> <pre><code>def expandAndReturnChildren(state_space, node):\n  children = []\n  for [m,n,c] in state_space:\n    if m == node:\n      children.append(n)\n    elif n == node:\n      children.append(m)\n  return children\n</code></pre> <p>The function will provide a list of the children of the <code>node</code>.</p>"},{"location":"lab3-uninformed-search/#node-in-the-search-tree","title":"Node in the search tree","text":"<p>We can use a class to represent each node in the search tree. The important information for each node includes the state and the parent of the node.</p> <pre><code>class Node:\n  def __init__(self, state=None, parent=None):\n    self.state = state\n    self.parent = parent\n</code></pre> <p>Class in Python</p> <p>In Python, to define a class, the class needs to have the function <code>__init__</code> with at least one input <code>self</code>. This function is called when an object is initiated with this class. The internal variable <code>self</code> defines the properties of the object. The input arguments apart from <code>self</code> for the function <code>__init__</code> are the parameters to be passed when initiating a new object.</p> <p>In a class, additional functions can also be defined, and these will be the methods for the object of this class. </p> <p>With this implementation of node as a class, the <code>expandAndReturnChildren</code> function is updated to be</p> <pre><code>def expandAndReturnChildren(state_space, node):\n  children = []\n  for [m,n,c] in state_space:\n    if m == node.state:\n      childnode = Node(n, node)\n      children.append(childnode)\n    elif n == node.state:\n      childnode = Node(m, node)\n      children.append(childnode)\n  return children\n</code></pre> <p>Quick check</p> <p>Your current code should look like</p> <pre><code>initial_state = \"Arad\"\ngoal_state = \"Bucharest\"\n\nstate_space = [\n  ['Arad', 'Zerind', 75],\n  ['Arad', 'Timisoara', 118],\n  ['Timisoara', 'Lugoj', 111],\n  ...\n]\n\nclass Node:\n  def __init__(self, state=None, parent=None):\n    self.state = state\n    self.parent = parent\n\ndef expandAndReturnChildren(state_space, node):\n  children = []\n  for [m,n,c] in state_space:\n    if m == node.state:\n      childnode = Node(n, node)\n      children.append(childnode)\n    elif n == node.state:\n      childnode = Node(m, node)\n      children.append(childnode)\n  return children\n</code></pre>"},{"location":"lab3-uninformed-search/#breadth-first-search-algorithm","title":"Breadth-first search algorithm","text":"<p>Next we will create a function to execute the search algorithm. The first algorithm we will use is the breadth-first search (BFS).</p> <p>We will separate the problem definition from the algorithm definition, the algorithm function will have the inputs of the state space, initial state and goal state. </p> <pre><code>def bfs(state_space, initial_state, goal_state):\n</code></pre> <p>Separation of definitions for problem and algorithm</p> <p>The separation of problem definition and the algorithm definition allows us to re-use the algorithm easily for other problems and also re-use the problem definition with other algorithms</p> <p>In this function, we need two empty arrays to store the frontier and the explored states.</p> <pre><code>def bfs(state_space, initial_state, goal_state):\n  frontier = []\n  explored = []\n</code></pre> <p>In BFS, we will use the initial state as our root node.</p> <pre><code>def bfs(state_space, initial_state, goal_state):\n  frontier = []\n  explored = []\n  frontier.append(Node(initial_state, None))\n</code></pre> <p><code>Node(initial_state, None)</code></p> <p>As the root node has no parent, we use <code>None</code> as the value of the parent of root node.</p> <p>When we are generating the search tree, we will continually expanding the first node (FIFO) in the frontier until we generate a node with goal state. Therefore we need to have a loop to repeatedly expanding the first node in the frontier until the goal node is generated.</p> <pre><code>def bfs(state_space, initial_state, goal_state):\n  frontier = []\n  explored = []\n  found_goal = False\n  frontier.append(Node(initial_state, None))\n\n  while not found_goal:\n    ...\n</code></pre> <p>In the loop we will first expand the first node in the frontier to obtain the children, and move the expanded node from frontier to the explored set.</p> <pre><code>  while not found_goal:\n    # expand the first in the frontier\n    children = expandAndReturnChildren(state_space, frontier[0])\n    # copy the node to the explored set\n    explored.append(frontier[0])\n    # remove the expanded node from the frontier\n    del frontier[0]\n</code></pre> <p>Check if the children generated should be added to the frontier or discarded. If any child is expanded previously, i.e. in the explored set, or if it is generated previously but not expanded yet, i.e. in the frontier, then it should be discarded. Else, it should be added to the frontier.</p> <pre><code>    del frontier[0]\n    # loop through the children\n    for child in children:\n      # check if a node was expanded or generated previously\n      if not (child.state in [e.state for e in explored]) and not (child.state in [f.state for f in frontier]):\n        # add child to the frontier\n        frontier.append(child)\n</code></pre> <p>List comprehension</p> <p><code>[e.state for e in explored]</code> is using the syntax of list comprehension. List comprehension provides a shorter syntax to create a new list. </p> <p>This example loops through the variable <code>explored</code> and create a list with the values of <code>.state</code> for each element (node) in the <code>explored</code> list.</p> <p>This one-liner is equivalent to</p> <pre><code>explored_nodes = []\nfor e in explored:\n  explored_nodes.append(e.state)\n</code></pre> <p>Before a child is added to the frontier, it should be tested for goal. If it has the goal state, the BFS algorithm should be terminated.</p> <pre><code>      if not (child.state in [e.state for e in explored]) and not (child.state in [f.state for f in frontier]):\n        # goal test\n        if child.state == goal_state:\n          found_goal = True\n          goal_node = child\n          break\n        # add child to the frontiers\n        frontier.append(child)\n</code></pre> <p>Now that the algorithm has identified the goal_node, we can trace the solution through the parent of the goal node all the way back to the root node (node with no parent). Then the function should return the solution of BFS.</p> <pre><code>  solution = [goal_node.state]\n  trace_node = goal_node\n  while trace_node.parent is not None:\n    solution.insert(0, trace_node.parent.state)\n    trace_node = trace_node.parent\n  return solution\n</code></pre>"},{"location":"lab3-uninformed-search/#running-the-algorithm","title":"Running the algorithm","text":"<p>Now we have two functions <code>expandAndReturnChildren</code> and <code>bfs</code>, alongside with the variables <code>state_space</code>, <code>initial_state</code>, and <code>goal_state</code>.</p> <p>To run a script to execute the <code>bfs</code> function, we can have the script file structured as such:</p> <pre><code>```python\ninitial_state = 'Arad'\ngoal_state = 'Bucharest'\n\nstate_space = [\n  ...\n]\n\nclass Node:\n  ...\n\ndef expandAndReturnChildren(...):\n  ...\n\ndef bfs(...):\n  ...\n\nprint('Solution: ' + str(bfs(state_space, initial_state, goal_state)))\n```\n</code></pre> <p>Beware that in Python, a <code>.py</code> file can also be used to define a Python library/module. To prevent the commands outside the function to be executed when the file is used as a library instead of a script, we can implement an extra condition check.</p> <pre><code>class Node:\n  ...\n\ndef expandAndReturnChildren(...):\n  ...\n\ndef bfs(...):\n  ...\n\nif __name__ == '__main__':\n  state_space = [\n  ...\n  ]\n\n  initial_state = 'Arad'\n  goal_state = 'Bucharest'\n\n  print('Solution: ' + str(bfs(state_space, initial_state, goal_state)))\n</code></pre> <p><code>__name__</code> is a special variable in Python that evaluates to the name of the current module. This variable has the value of <code>'__main__'</code> if it's called as the main program rather than a module or library.</p> <p>This part is essentially the <code>main</code> function in other programming languages like C++ and Java.</p> <p>Execute the script and resolve any error.</p>"},{"location":"lab3-uninformed-search/#question","title":"Question","text":"<ol> <li> <p>How can you modify the code to run other uninformed search algorithms such as uniform-cost search, depth-first search, etc.? Which part(s) of the code do you need to modify? You may extend the discussion to informed search.</p> </li> <li> <p>What would you modify the script to implement BFS on the vacuum world problem?</p> </li> </ol>"},{"location":"lab3-uninformed-search/#report","title":"Report","text":"<p>Submit a report discussing the problems you have encountered, how you have solved them, and your answer for the questions.</p>"},{"location":"archive/202301/get-start/","title":"Getting started","text":"<p>The labs for ETC2073 Artificial Intelligence will be using Python as the programming language. The Anaconda distribution of Python is recommended, however, if you are familiar and comfortable with the vanilla distribution of Python. For those who have not installed Python in their machine, proceed to next session. This page only covers the installation of the Anaconda platform as, in my opinion, it is more beginner friendly in terms of installing packages and encapsulating environments.</p>"},{"location":"archive/202301/get-start/#installation","title":"Installation","text":"<ol> <li> <p>Download the Anaconda installer with Python 3 for your system from https://www.anaconda.com/distribution/.</p> </li> <li> <p>Use the graphical installer to install Anaconda.</p> </li> </ol>"},{"location":"archive/202301/get-start/#launching-ide","title":"Launching IDE","text":"<p>You will be using the Spyder IDE for Python. Feel free to use other IDE or code editor with terminal if that's your preference.</p> <ol> <li> <p>Start the Anaconda Navigator from your application list.</p> </li> <li> <p>From Anaconda <code>base</code> environment, launch Spyder IDE.</p> </li> <li> <p>The Spyder IDE consists of three parts: the editor, the variable explorer, and the IPython Console.</p> </li> <li> <p>The editor is where you write your codes.</p> </li> <li> <p>The variable explorer shows the value of the variable after running the code.</p> </li> <li> <p>The IPython console allows you to execute commands, interact with the running code, and display visualisation.</p> </li> <li> <p>After the code is written in the editor, you can execute the code using F5 to run file.</p> </li> <li> <p>Then the variables and their values can be found in the variable explorer.</p> </li> </ol>"},{"location":"archive/202301/lab1-fuzzy/","title":"Lab 1: Fuzzy Systems","text":""},{"location":"archive/202301/lab1-fuzzy/#lab-learning-outcomes","title":"Lab learning outcomes","text":"<p>After completing this lab, the students are able to</p> <ul> <li>construct a Mamdani fuzzy system using the <code>scikit-fuzzy</code> Python library and</li> <li>evaluate the result of the constructed fuzzy system.</li> </ul>"},{"location":"archive/202301/lab1-fuzzy/#note","title":"Note","text":"<p>Install the <code>scikit-fuzzy</code> Python library in your environment before proceeding with the lab.</p> <pre><code>conda install -c conda-forge scikit-fuzzy\n</code></pre>"},{"location":"archive/202301/lab1-fuzzy/#fuzzy-control-system-for-a-train","title":"Fuzzy control system for a train","text":"<ol> <li> <p>Consider a fuzzy control system to control the brake and throttle of a train based on the speed of the train and the distance of the train to the next stop.</p> </li> <li> <p>Import the <code>skfuzzy</code>, <code>skfuzzy.control</code>, and <code>numpy</code>.</p> <pre><code>import numpy as np\nfrom skfuzzy import control as ctrl\nfrom skfuzzy import membership as mf\n</code></pre> </li> </ol>"},{"location":"archive/202301/lab1-fuzzy/#initialise-inputs-and-outputs","title":"Initialise inputs and outputs","text":"<ol> <li> <p>Speed and distance are the inputs of the system whereas brake and throttle are the outputs.</p> </li> <li> <p>The ranges for the variables are:</p> Variable Range Speed 0 - 85 km/h Distance 0 - 3000 m Brake 0 - 100% Throttle 0 - 100% </li> <li> <p>As the inputs will be the antecedents of the rules, construct the variables <code>speed</code> and <code>distance</code> as <code>skfuzzy.control.Antecedent</code> objects. </p> <pre><code>speed = ctrl.Antecedent(np.arange(0, 85, 0.1), 'speed')\n</code></pre> </li> <li> <p>The initialisation function for <code>skfuzzy.control.Antecedent</code> object takes 2 arguments, the first is the universe of the variable, i.e. the values the variables can take, the second is the label of the variable. The initialisation function for <code>skfuzzy.control.Consequent</code> is similar. </p> </li> <li> <p>The label and the range of the variable can be accessed using <code>.label</code> and <code>.universe</code> respectively.</p> </li> </ol> <p>Task: Initialise the variables <code>distance</code> as <code>Antecedent</code> object, and <code>brake</code> and <code>throttle</code> as <code>Consequent</code> objects. (Outputs of the system will be consequents of the rules)</p>"},{"location":"archive/202301/lab1-fuzzy/#define-membership-functions-for-fuzzy-sets-of-variables","title":"Define membership functions for fuzzy sets of variables","text":"<ol> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>speed (0 to 85 km/h)</p> Linguistic value Fit vector Stopped (1/0, 0/2) Very slow (0/1, 1/2.5, 0/4) Slow (0/2.5, 1/6.5, 0/10.5) Medium fast (0/6.5, 1/26.5, 0/46.5) Fast (0/26.5, 1/70, 1/85) </li> <li> <p>distance (0 to 3000 m)</p> Linguistic value Fit vector At (1/0, 0/2) Very near (0/1, 1/3, 0/5) Near (0/3, 1/101.5, 0/200) Medium far (0/100, 1/1550, 0/3000) Far (0/1500, 1/2250, 1/3000) </li> <li> <p>brake (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/40) Very slight (0/20, 1/50, 0/80) Slight (0/70, 1/83.5, 0/97) Medium (0/95, 1/97, 0/99) Full (0/98, 1/100) </li> <li> <p>throttle (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/2) Very slight (0/1, 1/3, 0/5) Slight (0/3, 1/16.5, 0/30) Medium (0/20, 1/50, 0/80) Full (0/60, 1/80, 1/100) </li> </ul> </li> <li> <p>The <code>skfuzzy.membership</code> module provides the following membership functions:</p> Membership function Description <code>skfuzzy.membership.dsigmf(x, b1, c1, b2, c2)</code> Difference of two fuzzy sigmoid membership functions <code>skfuzzy.membership.gauss2mf(x, mean1, ...)</code> Gaussian fuzzy membership function of two combined Gaussians <code>skfuzzy.membership.gaussmf(x, mean, sigma)</code> Gaussian fuzzy membership function <code>skfuzzy.membership.gbellmf(x, a, b, c)</code> Generalized Bell function fuzzy membership generator <code>skfuzzy.membership.piecemf(x, abc)</code> Piecewise linear membership function (particularly used in FIRE filters) <code>skfuzzy.membership.pimf(x, a, b, c, d)</code> Pi-function fuzzy membership generator <code>skfuzzy.membership.psigmf(x, b1, c1, b2, c2)</code> Product of two sigmoid membership functions <code>skfuzzy.membership.sigmf(x, b, c)</code> The basic sigmoid membership function generator <code>skfuzzy.membership.smf(x, a, b)</code> S-function fuzzy membership generator <code>skfuzzy.membership.trapmf(x, abcd)</code> Trapezoidal membership function generator <code>skfuzzy.membership.trimf(x, abc)</code> Triangular membership function generator <code>skfuzzy.membership.zmf(x, a, b)</code> Z-function fuzzy membership generator </li> <li> <p>The fit vector of a linguitic value can be assigned to a linguistic variable using</p> <pre><code>speed['stopped'] = mf.trimf(speed.universe, [0, 0, 2])\nspeed['very slow'] = mf.trimf(speed.universe, [1, 2.5, 4])\n</code></pre> <p>Task: Assign all fuzzy sets to the linguistic variables.</p> </li> <li> <p>The fuzzy set diagram of a linguistic variable can be viewed using <code>.view()</code></p> <pre><code>speed.view()\n</code></pre> <p>Task: Check if the fuzzy set diagrams match the fit vectors.</p> </li> </ol>"},{"location":"archive/202301/lab1-fuzzy/#define-rules","title":"Define rules","text":"<ol> <li> <p>The rules for this system are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Distance At Very near Near Medium far Far Speed Stopped Full brakeNo throttle Full brakeVery slight throttle Very slow Full brakeNo throttle Medium brakeVery slight throttle Slight brakeVery slight throttle Slow Full brakeNo throttle Medium brakeVery slight throttle Very slight brakeSlight throttle Medium fast Very slight brakeMedium throttle No brakeFull throttle Fast Very slight brakeMedium throttle No brakeFull throttle </p> </li> <li> <p>Rule can be defined using <code>skfuzzy.control.Rule(antecedent, consequent, label)</code>. To define the first rule, i.e. if distance is 'at' and speed is 'stopped', then full brake and no throttle, </p> <pre><code>rule1 = ctrl.Rule(distance['at'] &amp; speed['stopped'], (brake['full'], throttle['no']))\n</code></pre> <p>If the antecedent consists of multiple parts, they can be combined using operators <code>|</code> (OR), <code>&amp;</code> (AND), and <code>~</code> (NOT).</p> <p>If the consequent consists of multiple parts, they can be combined as a <code>list</code>/<code>tuple</code>.</p> <p>Task: Define all the rules. Then combine all the rules in a <code>list</code>, i.e. <code>rules = [rule1, rule2, ...]</code>.</p> </li> </ol>"},{"location":"archive/202301/lab1-fuzzy/#construct-the-fuzzy-control-system","title":"Construct the fuzzy control system","text":"<ol> <li> <p>The train control system can be constructed with</p> <pre><code>train_ctrl = ctrl.ControlSystem(rules=rules)\n</code></pre> </li> <li> <p>A <code>skfuzzy.control.ControlSystemSimulation</code> object is needed to simulate the control system to obtain the outputs given certain inputs.</p> <pre><code>train = ctrl.ControlSystemSimulation(control_system=train_ctrl)\n</code></pre> </li> <li> <p>To obtain the values for <code>brake</code> and <code>throttle</code> given that <code>speed</code> is 30 km/h and <code>distance</code> is 6 m,</p> <pre><code># define the values for the inputs\ntrain.input['speed'] = 30\ntrain.input['distance'] = 2000\n\n# compute the outputs\ntrain.compute()\n\n# print the output values\nprint(train.output)\n\n# to extract one of the outputs\nprint(train.output['brake'])\n</code></pre> </li> <li> <p>To view the results in the graph,</p> <pre><code>brake.view(sim=train)\nthrottle.view(sim=train)\n</code></pre> </li> </ol>"},{"location":"archive/202301/lab1-fuzzy/#view-the-controloutput-space","title":"View the control/output space","text":"<ol> <li> <p>The control/output space allows us to identify if the outputs fit our expectation.</p> </li> <li> <p>Construct an empty 3D space with 100-by-100 x-y grid.</p> <pre><code>x, y = np.meshgrid(np.linspace(speed.universe.min(), speed.universe.max(), 100),\n                   np.linspace(distance.universe.min(), distance.universe.max(), 100))\nz_brake = np.zeros_like(x, dtype=float)\nz_throttle = np.zeros_like(x, dtype=float)\n</code></pre> </li> <li> <p>Loop through every point and identify the value of brake and throttle of each point. As the specified rules are not exhaustive, i.e. some input combinations do not activate any rule, we will set the output of such input combinations to be <code>float('inf')</code>.     <pre><code>for i,r in enumerate(x):\n  for j,c in enumerate(r):\n    train.input['speed'] = x[i,j]\n    train.input['distance'] = y[i,j]\n    try:\n      train.compute()\n    except:\n      z_brake[i,j] = float('inf')\n      z_throttle[i,j] = float('inf')\n    z_brake[i,j] = train.output['brake']\n    z_throttle[i,j] = train.output['throttle']\n</code></pre></p> </li> <li> <p>Plot the result in a 3D graph using the <code>matplotlib.pyplot</code> library.</p> <pre><code>import matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef plot3d(x,y,z):\n  fig = plt.figure()\n  ax = fig.add_subplot(111, projection='3d')\n\n  ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='viridis', linewidth=0.4, antialiased=True)\n\n  ax.contourf(x, y, z, zdir='z', offset=-2.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='x', offset=x.max()*1.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='y', offset=y.max()*1.5, cmap='viridis', alpha=0.5)\n\n  ax.view_init(30, 200)\n\nplot3d(x, y, z_brake)\nplot3d(x, y, z_throttle)\n</code></pre> </li> </ol>"},{"location":"archive/202301/lab1-fuzzy/#fuzzy-tipping-recommendation-system","title":"Fuzzy tipping recommendation system","text":"<ol> <li> <p>A fuzzy expert system is designed to identify the percentage of tips a customer will give based on the service and the food the customer received.</p> </li> <li> <p>The system has service rating and food rating as inputs, and tips as output.</p> </li> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>service (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>food (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>tips (0 to 30%)</p> Linguistic value Fit vector Low (1/0, 0/15) Medium (0/0, 1/15, 0/30) High (0/15, 1/30) </li> </ul> </li> <li> <p>The rules are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Food Poor Average Good Service Poor low tips low tips medium tips Average low tips medium tips high tips Good medium tips high tips high tips </p> </li> </ol> <p>Task: Construct the fuzzy inference system.</p> <p>Task: Discuss, if you were to make at least one modification to the fuzzy tipping recommendation system, what it will be and why.</p>"},{"location":"archive/202301/lab1-fuzzy/#report","title":"Report","text":"<p>Submit a report detailing the process, results, graphs, and your observations.</p>"},{"location":"archive/202301/lab2-uninformed-search/","title":"Lab 2: Breadth-First Search","text":""},{"location":"archive/202301/lab2-uninformed-search/#lab-learning-outcomes","title":"Lab learning outcomes","text":"<p>After completing this lab, the students are able to </p> <ul> <li>create Python script to execute breadth-first search algorithm to solve a search problem.</li> </ul>"},{"location":"archive/202301/lab2-uninformed-search/#nicks-route-finding-problem-in-romania","title":"Nick's route-finding problem in Romania","text":"<p>The first search problem we are focusing on is Nick\u2019s route-finding problem in Romania, starting in Arad to reach Bucharest. The road map of Romania, which is the state space of the problem is given as follows:</p> 75 71 151 140 118 111 70 75 120 146 80 99 97 138 101 211 90 85 98 86 142 92 87 Arad Zerind Oradea Sibiu Fagaras Rimnicu Vilcea Pitesti Craiova Drobeta Mehadia Lugoj Timisoara Bucharest Giurgiu Urziceni Hirsova Eforie Vaslui Iasi Neamt <p>To solve the problem, we need to define the representation of the state, determine the transition model, and the execution of the search algorithm.</p>"},{"location":"archive/202301/lab2-uninformed-search/#state-representation","title":"State representation","text":"<p>In this problem the only state we need to consider is the location of Nick. Therefore we can use the names of the cities as the state.</p> <p>Since Nick is starting in Arad, going to Bucharest, we can define the initial state and goal state as</p> <pre><code>initial_state = \"Arad\"\ngoal_state = \"Bucharest\"\n</code></pre>"},{"location":"archive/202301/lab2-uninformed-search/#transition-model-and-state-space","title":"Transition model and state space","text":"<p>The transition model provides the way to identify the child of a node in a search tree given a specific action. In this problem, we need to translate the whole state space from the geographical network into the program together with the step costs between the connected states.</p> <p>The important information from the state space is the connections between states and the step costs between connected states. Notice that in this problem the connections are reversible. Therefore in our state space the connection from Arad to Zerind and the connection from Zerind to Arad are identical, hence only one instance of that connection is needed.</p> <p>The most straightforward way of defining the state space is by using a nested array, in which each inner array consists of the two connected states and its cost. </p> <p>Define a variable <code>state_space</code> to store the state space. The following code shows the first three elements in the nested array. Complete the definition of the variable by referring to the state space provided.</p> <pre><code>state_space = [\n  ['Arad', 'Zerind', 75],\n  ['Arad', 'Timisoara', 118],\n  ['Timisoara', 'Lugoj', 111],\n  ...\n]\n</code></pre> <p>In this problem, the actions are to travel to connected cities from the current city Nick is in. The transition model is directly defined by the action. Therefore, create a function to search through the state space to find the children of a node, which would suffice as actions and transition model.</p> <p>This function loops through the <code>state_space</code> variable to check for connections linked to the current node. The state on the connection becomes the child of the node in the search tree. We define a new function called <code>expandAndReturnChildren</code>.</p> <pre><code>def expandAndReturnChildren(state_space, node):\n  children = []\n  for [m,n,c] in state_space:\n    if m == node:\n      children.append(n)\n    elif n == node:\n      children.append(m)\n  return children\n</code></pre> <p>The function will provide a list of the children of the <code>node</code>.</p>"},{"location":"archive/202301/lab2-uninformed-search/#node-in-the-search-tree","title":"Node in the search tree","text":"<p>We can use a class to represent each node in the search tree. The important information for each node includes the state and the parent of the node.</p> <pre><code>class Node:\n  def __init__(self, state=None, parent=None):\n    self.state = state\n    self.parent = parent\n</code></pre> <p>Class in Python</p> <p>In Python, to define a class, the class needs to have the function <code>__init__</code> with at least one input <code>self</code>. This function is called when an object is initiated with this class. The internal variable <code>self</code> defines the properties of the object. The input arguments apart from <code>self</code> for the function <code>__init__</code> are the parameters to be passed when initiating a new object.</p> <p>In a class, additional functions can also be defined, and these will be the methods for the object of this class. </p> <p>With this implementation of node as a class, the <code>expandAndReturnChildren</code> function is updated to be</p> <pre><code>def expandAndReturnChildren(state_space, node):\n  children = []\n  for [m,n,c] in state_space:\n    if m == node.state:\n      childnode = Node(n, node)\n      children.append(childnode)\n    elif n == node.state:\n      childnode = Node(m, node)\n      children.append(childnode)\n  return children\n</code></pre> <p>Quick check</p> <p>Your current code should look like</p> <pre><code>initial_state = \"Arad\"\ngoal_state = \"Bucharest\"\n\nstate_space = [\n  ['Arad', 'Zerind', 75],\n  ['Arad', 'Timisoara', 118],\n  ['Timisoara', 'Lugoj', 111],\n  ...\n]\n\nclass Node:\n  def __init__(self, state=None, parent=None):\n    self.state = state\n    self.parent = parent\n\ndef expandAndReturnChildren(state_space, node):\n  children = []\n  for [m,n,c] in state_space:\n    if m == node.state:\n      childnode = Node(n, node)\n      children.append(childnode)\n    elif n == node.state:\n      childnode = Node(m, node)\n      children.append(childnode)\n  return children\n</code></pre>"},{"location":"archive/202301/lab2-uninformed-search/#breadth-first-search-algorithm","title":"Breadth-first search algorithm","text":"<p>Next we will create a function to execute the search algorithm. The first algorithm we will use is the breadth-first search (BFS).</p> <p>We will separate the problem definition from the algorithm definition, the algorithm function will have the inputs of the state space, initial state and goal state. </p> <pre><code>def bfs(state_space, initial_state, goal_state):\n</code></pre> <p>Separation of definitions for problem and algorithm</p> <p>The separation of problem definition and the algorithm definition allows us to re-use the algorithm easily for other problems and also re-use the problem definition with other algorithms</p> <p>In this function, we need two empty arrays to store the frontier and the explored states.</p> <pre><code>def bfs(state_space, initial_state, goal_state):\n  frontier = []\n  explored = []\n</code></pre> <p>In BFS, we will use the initial state as our root node.</p> <pre><code>def bfs(state_space, initial_state, goal_state):\n  frontier = []\n  explored = []\n  frontier.append(Node(initial_state, None))\n</code></pre> <p><code>Node(initial_state, None)</code></p> <p>As the root node has no parent, we use <code>None</code> as the value of the parent of root node.</p> <p>When we are generating the search tree, we will continually expanding the first node (FIFO) in the frontier until we generate a node with goal state. Therefore we need to have a loop to repeatedly expanding the first node in the frontier until the goal node is generated.</p> <pre><code>def bfs(state_space, initial_state, goal_state):\n  frontier = []\n  explored = []\n  found_goal = False\n  frontier.append(Node(initial_state, None))\n\n  while not found_goal:\n    ...\n</code></pre> <p>In the loop we will first expand the first node in the frontier to obtain the children, and move the expanded node from frontier to the explored set.</p> <pre><code>  while not found_goal:\n    # expand the first in the frontier\n    children = expandAndReturnChildren(state_space, frontier[0])\n    # copy the node to the explored set\n    explored.append(frontier[0])\n    # remove the expanded node from the frontier\n    del frontier[0]\n</code></pre> <p>Check if the children generated should be added to the frontier or discarded. If any child is expanded previously, i.e. in the explored set, or if it is generated previously but not expanded yet, i.e. in the frontier, then it should be discarded. Else, it should be added to the frontier.</p> <pre><code>    del frontier[0]\n    # loop through the children\n    for child in children:\n      # check if a node was expanded or generated previously\n      if not (child.state in [e.state for e in explored]) and not (child.state in [f.state for f in frontier]):\n        # add child to the frontier\n        frontier.append(child)\n</code></pre> <p>List comprehension</p> <p><code>[e.state for e in explored]</code> is using the syntax of list comprehension. List comprehension provides a shorter syntax to create a new list. </p> <p>This example loops through the variable <code>explored</code> and create a list with the values of <code>.state</code> for each element (node) in the <code>explored</code> list.</p> <p>This one-liner is equivalent to</p> <pre><code>explored_nodes = []\nfor e in explored:\n  explored_nodes.append(e.state)\n</code></pre> <p>Before a child is added to the frontier, it should be tested for goal. If it has the goal state, the BFS algorithm should be terminated.</p> <pre><code>      if not (child.state in [e.state for e in explored]) and not (child.state in [f.state for f in frontier]):\n        # goal test\n        if child.state == goal_state:\n          found_goal = True\n          goal_node = child\n          break\n        # add child to the frontiers\n        frontier.append(child)\n</code></pre> <p>Now that the algorithm has identified the goal_node, we can trace the solution through the parent of the goal node all the way back to the root node (node with no parent). Then the function should return the solution of BFS.</p> <pre><code>  solution = [goal_node.state]\n  trace_node = goal_node\n  while trace_node.parent is not None:\n    solution.insert(0, trace_node.parent.state)\n    trace_node = trace_node.parent\n  return solution\n</code></pre>"},{"location":"archive/202301/lab2-uninformed-search/#running-the-algorithm","title":"Running the algorithm","text":"<p>Now we have two functions <code>expandAndReturnChildren</code> and <code>bfs</code>, alongside with the variables <code>state_space</code>, <code>initial_state</code>, and <code>goal_state</code>.</p> <p>To run a script to execute the <code>bfs</code> function, we can have the script file structured as such:</p> <pre><code>```python\ninitial_state = 'Arad'\ngoal_state = 'Bucharest'\n\nstate_space = [\n  ...\n]\n\nclass Node:\n  ...\n\ndef expandAndReturnChildren(...):\n  ...\n\ndef bfs(...):\n  ...\n\nprint('Solution: ' + str(bfs(state_space, initial_state, goal_state)))\n```\n</code></pre> <p>Beware that in Python, a <code>.py</code> file can also be used to define a Python library/module. To prevent the commands outside the function to be executed when the file is used as a library instead of a script, we can implement an extra condition check.</p> <pre><code>class Node:\n  ...\n\ndef expandAndReturnChildren(...):\n  ...\n\ndef bfs(...):\n  ...\n\nif __name__ == '__main__':\n  state_space = [\n  ...\n  ]\n\n  initial_state = 'Arad'\n  goal_state = 'Bucharest'\n\n  print('Solution: ' + str(bfs(state_space, initial_state, goal_state)))\n</code></pre> <p><code>__name__</code> is a special variable in Python that evaluates to the name of the current module. This variable has the value of <code>'__main__'</code> if it's called as the main program rather than a module or library.</p> <p>This part is essentially the <code>main</code> function in other programming languages like C++ and Java.</p> <p>Execute the script and resolve any error.</p>"},{"location":"archive/202301/lab2-uninformed-search/#question","title":"Question","text":"<ol> <li> <p>How can you modify the code to run other uninformed search algorithms such as uniform-cost search, depth-first search, etc.? Which part(s) of the code do you need to modify? You may extend the discussion to informed search.</p> </li> <li> <p>What would you modify the script to implement BFS on the vacuum world problem?</p> </li> </ol>"},{"location":"archive/202301/lab2-uninformed-search/#report","title":"Report","text":"<p>Submit a report discussing the problems you have encountered, how you have solved them, and your answer for the questions.</p>"},{"location":"archive/202301/lab3-informed-search/","title":"Lab 3: Informed Search","text":""},{"location":"archive/202301/lab3-informed-search/#lab-learning-outcomes","title":"Lab learning outcomes","text":"<p>After completing this lab, the students are able to </p> <ul> <li>create Python script to execute an informed search algorithm to solve a search problem.</li> </ul>"},{"location":"archive/202301/lab3-informed-search/#nicks-route-finding-problem-in-romania","title":"Nick's route-finding problem in Romania","text":"<p>The search problem we are focusing on for this lab is Nick\u2019s route-finding problem in Romania, starting in Arad to reach Bucharest. The road map of Romania, which is the state space of the problem is given as follows:</p> 75 71 151 140 118 111 70 75 120 146 80 99 97 138 101 211 90 85 98 86 142 92 87 Arad Zerind Oradea Sibiu Fagaras Rimnicu Vilcea Pitesti Craiova Drobeta Mehadia Lugoj Timisoara Bucharest Giurgiu Urziceni Hirsova Eforie Vaslui Iasi Neamt <p>Write a Python script to solve the problem with greedy-best-first search algorithm. In the process of writing the script, answer the following quesetions.</p> <ol> <li> <p>Explain the logical flow of the transition model.</p> </li> <li> <p>What is a reasonable heuristic function for this problem?</p> </li> <li> <p>What is/are the difference(s) between breadth-first search algorithm and greedy-best-first search? How would these differences be reflected in the script?</p> </li> <li> <p>Explain the logical flow of sorting the frontier for node expansion.</p> </li> <li> <p>Explain the logical flow of identifying the solution when the goal node is found.</p> </li> </ol>"},{"location":"archive/202301/lab3-informed-search/#report","title":"Report","text":"<p>Submit a written report that describes the considerations while writing the scripts, the answers to the above questions, and the problems you encountered in the process. Include your script in the written report as an appendix.</p>"},{"location":"archive/202301/lab4-particle-swarm-optimisation/","title":"Lab 4: Particle Swarm Optimisastion","text":""},{"location":"archive/202301/lab4-particle-swarm-optimisation/#lab-learning-outcomes","title":"Lab learning outcomes","text":"<p>After completing this lab, the students are able to</p> <ul> <li>develop a Python function to perform global best particle swarm optimisation.</li> </ul>"},{"location":"archive/202301/lab4-particle-swarm-optimisation/#setup-for-spyder","title":"Setup for Spyder","text":"<ol> <li> <p>If you are using Spyder for this lab, go to Tools &gt; Preferences &gt; IPython console &gt; Graphics and set Backend to Automatic.</p> </li> <li> <p>Restart kernel by going to Consoles &gt; Restart kernel.</p> </li> </ol>"},{"location":"archive/202301/lab4-particle-swarm-optimisation/#problem-to-solve","title":"Problem to solve","text":"<p>Solve the following problem using global best particle swarm optimisation:</p> <p>Problem</p> <p>Find the value of x to minimise the function \\(f(x) = (x+100)(x+50)(x)(x-20)(x-60)(x-100)\\) for \\(-100 &lt; x &lt; 100\\)</p>"},{"location":"archive/202301/lab4-particle-swarm-optimisation/#particle-swarm-optimisation","title":"Particle swarm optimisation","text":"particles initialisation personal best identification global best identification velocity calculation position update repeat from personal best identification until termination"},{"location":"archive/202301/lab4-particle-swarm-optimisation/#parameter-definition","title":"Parameter definition","text":"<ol> <li> <p>With global best particle swarm optimisaton, the position update function is given by</p> \\[x_i(t+1) = x_i(t) + v_i(t+1)\\] <p>and the velocity update function is</p> \\[v_i(t+1) = v_i(t) + \\alpha_1\\beta_1(t) \\Big( p_i(t) - x_i(t) \\Big) + \\alpha_2\\beta_2(t)\\Big(p_g(t) - x_i(t)\\Big)\\] </li> <li> <p>\u03b1<sub>1</sub> and \u03b1<sub>2</sub> are acceleration constants that are fixed throughout the algorithm. Define a small value for \u03b1<sub>1</sub> and \u03b1<sub>2</sub>, for example <code>0.1</code>.</p> <pre><code>alpha = [0.1, 0.1]\n</code></pre> </li> <li> <p>\u03b2<sub>1</sub>(t) and \u03b2<sub>2</sub>(t) are random values between <code>0</code> and <code>1</code> that are regenerated every iteration. Therefore no definition is required.</p> </li> <li> <p>Also, define the number of particles to run the algorithm with.</p> <pre><code>n_particle = 10\n</code></pre> </li> <li> <p>Place the definition of these variables in the <code>__main__</code> block.</p> <pre><code>if __name__ == '__main__':\n  alpha = [0.1, 0.1]\n  n_particle = 10\n</code></pre> </li> </ol>"},{"location":"archive/202301/lab4-particle-swarm-optimisation/#create-a-class-for-particle","title":"Create a class for particle","text":"<ol> <li> <p>As each particle is an individual, create a <code>Particle</code> class to hold the data of the particle's current position, velocity, and personal best position.</p> <pre><code>class Particle:\n  def __init__(self, position = 0, velocity = 0):\n    self.position = position\n    self.velocity = velocity\n    self.best_position = position\n</code></pre> </li> </ol>"},{"location":"archive/202301/lab4-particle-swarm-optimisation/#fitness-function","title":"Fitness function","text":"<ol> <li> <p>Fitness function is how we can compare different particles.</p> </li> <li> <p>As our goal is to minimise f(x) as stated in the beginning, we will use f(x) as our fitness function.</p> </li> <li> <p>By using f(x) in minimisation problem, it implies that the lower the value of f(x), the better the particle it is.</p> </li> <li> <p>The value of x is the position of the particle.</p> </li> <li> <p>Define the fitness function as a Python function.</p> <pre><code>def fit_fcn(position):\n  ...\n  return fitness\n</code></pre> </li> </ol>"},{"location":"archive/202301/lab4-particle-swarm-optimisation/#initialise-particles","title":"Initialise particles","text":"<ol> <li> <p>Particles are initialised with random positions within the constraints. </p> </li> <li> <p>At initialisation, we may assume that the initial velocities of all the particles. It is possible to initialise particles with non-zero velocities. For now, we will stick to zero initial velocities.</p> </li> <li> <p>Define a Python function that takes the input of the number of particles and the limits of the positions to initialise and return a list of objects of class <code>Particle</code>. Each particle has random position within the limits and zero velocity.</p> <pre><code>def initialise_particles(n_ptc, position_limits):\n  # position_limits is a list of two values. The first value is the lower boundary and the second value is the upper boundary.\n  ...\n  return particles\n</code></pre> </li> <li> <p>Remember to test your function before proceed.</p> </li> </ol>"},{"location":"archive/202301/lab4-particle-swarm-optimisation/#update-personal-best","title":"Update personal best","text":"<ol> <li> <p>Create a method in the class <code>Particle</code> to update the <code>best_position</code> if necessary.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(self):\n    # 1. calculate the fitnesses of the best_position and the particle's current position\n    # 2. compare the fitnesses and determine if the current position is better than the best_position\n    # 3. update if necessary\n    # 4. no return statement is required\n</code></pre> </li> <li> <p>If the new position has a lower fitness, i.e. the new position is better than the best position, update the <code>best_position</code> to hold the value of the new position.</p> </li> </ol>"},{"location":"archive/202301/lab4-particle-swarm-optimisation/#update-global-best","title":"Update global best","text":"<ol> <li> <p>Initiate a variable named <code>global_best_position</code> with the value <code>None</code> in the <code>__main__</code> block. </p> </li> <li> <p>Create a function that takes two positions as inputs, compare them, and return the better position of the two.</p> <pre><code>def compareFitness(pos1, pos2):\n  # 1. calculate the fitness of pos1 and pos2\n  # 2. compare to determine the better position\n  return betterpos\n</code></pre> </li> <li> <p>We will later use this function to compare the current global best position with the personal best position of each particle.</p> </li> </ol>"},{"location":"archive/202301/lab4-particle-swarm-optimisation/#update-velocity","title":"Update velocity","text":"<ol> <li> <p>Create a method in the class <code>Particle</code> to update the velocity given \u03b1<sub>1</sub>, \u03b1<sub>2</sub>, \u03b2<sub>1</sub>, \u03b2<sub>2</sub>, and the global best position.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(...):\n    ...\n\n  def update_velocity(self, alpha, beta, glob_best_pos):\n    # alpha is a list of two values. we will access alpha_1 and alpha_2 by alpha[0] and alpha[1] respectively. This also applies to beta.\n    # the current position, current velocity, and personal best position of the particle can be accessed by self.position, self.velocity, and self.best_position\n    # assign the particle's velocity with the updated velocity\n</code></pre> </li> </ol>"},{"location":"archive/202301/lab4-particle-swarm-optimisation/#update-particle-position","title":"Update particle position","text":"<ol> <li> <p>As updating a particle position only require information from within the particle object and the limits of the position, create a method called <code>update_position</code> in the class <code>Particle</code> taking the input of the limits of the position.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(...):\n    ...\n\n  def update_velocity(...):\n    ...\n\n  def update_position(self, position_limits):\n    self.position = self.position + self.velocity\n    # how should you solve the problem of the position (x) going out of the limits\n</code></pre> </li> </ol>"},{"location":"archive/202301/lab4-particle-swarm-optimisation/#create-a-loop-until-termination","title":"Create a loop (until termination)","text":"<ol> <li> <p>Consider the following termination criteria:</p> <ul> <li>exceeding 200 iterations</li> <li>fitnesses of all particles are close</li> <li>positions of all particles are close</li> </ul> </li> <li> <p>Create a function to calculate the average difference between the mean fitness and the fitness of each particle.</p> <pre><code>def calc_avg_fit_diff(particles):\n  # 1. calculate mean fitness of all particles\n  # 2. calculate the difference between the mean fitness and the fitness of each particle\n  # 3. calculate the average of the differences obtained from step 2\n  return avg_fit_diff\n</code></pre> </li> <li> <p>Create a function to calculate the average difference between the mean position and the position of each particle.</p> <pre><code>def calc_avg_pos_diff(particles):\n  # 1. calculate mean position of all particles\n  # 2. calculate the difference between the mean position and the position of each particle\n  # 3. calculate the average of the differences obtained from step 2\n  return avg_pos_diff\n</code></pre> </li> <li> <p>Create a loop (in the <code>__main__</code> block) to execute the global best particle swarm optimisation (gbest PSO) until termination. </p> <pre><code>if __name__ == '__main__':\n  # parameter initialisation\n  alpha = [0.1, 0.1]\n  n_particle = 10\n  global_best_position = None\n  position_limits = [-100, 100]\n  # termination threshold\n  iteration = 0\n  max_iter = 200\n  min_avg_fit_diff = 0.1\n  min_avg_pos_diff = 0.1\n  # initialise particles\n  particles = initialise_particles(n_particle, position_limits)\n  while (...): # how should you define the termination criteria here?\n    print(iteration, [round(x.position,2) for x in particles])\n    for particle in particles:\n      # update personal best\n      particle.update_personal_best()\n      # update global best\n      if global_best_position == None:\n        global_best_position = particle.position\n      else:\n        global_best_position = compareFitness(global_best_position, particle.position)\n    # generate beta randomly for current iteration\n    beta = [random.random(), random.random()]\n    for particle in particles:\n      # update velocity\n      particle.update_velocity(alpha, beta, global_best_position)\n      # update position\n      particle.update_position(position_limits)\n    iteration += 1\n  # display results\n  print(iteration, [round(x.position,2) for x in particles])\n</code></pre> </li> </ol>"},{"location":"archive/202301/lab4-particle-swarm-optimisation/#visualisation","title":"Visualisation","text":"<ol> <li> <p>Let's add a few lines to visualise particles \"flying\" towards to optimal position.</p> <ul> <li> <p>import the visualisation library   <pre><code>import matplotlib.pyplot as plt\n</code></pre></p> </li> <li> <p>add the following lines just before the <code>while</code> loop in the last code block in the previous section. This is to plot the existing particle positions on the graph.   <pre><code>space_ax = plt.axes()\nspace_ax.plot(list(range(*position_limits)),[fit_fcn(x) for x in range(*position_limits)])\nspace_ax.set_title(\"Position of particles in iteration {}\".format(iteration))\nspace_ax.set_xlabel(\"Position\")\nspace_ax.set_ylabel(\"Fitness\")\n</code></pre></p> </li> <li> <p>add the following lines between line 14 and line 15 in the last code block in the previous section, as well as after line 33. This is to remove the existing particle positions and plot the new positions, i.e to visually update the positions.   <pre><code>if len(space_ax.lines) &gt; 1:\n  del space_ax.lines[1]\nspace_ax.plot([x.position for x in particles], [fit_fcn(x.position) for x in particles], 'go')\nspace_ax.set_title(\"Position of particles in iteration {}\".format(iteration))\nplt.pause(0.5) # pause the program for 0.5 second; if graph changes too quickly, increase this value; you can also speed up the process by decreasing this value\n</code></pre></p> </li> </ul> </li> </ol>"},{"location":"archive/202301/lab4-particle-swarm-optimisation/#evaluation","title":"Evaluation","text":"<ol> <li> <p>Store the values of the variables at each iteration for analysis and evaluation.</p> <ul> <li>position of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.position_list = [position]\n\n  def update_position(...):\n    ...\n    self.position_list.append(self.position)\n</code></pre> <ul> <li>velocity of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.velocity_list = [velocity]\n\n  def update_velocity(...):\n    ...\n    self.velocity_list.append(self.velocity)\n</code></pre> <ul> <li>personal best position of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.best_position_list = []\n\n  def update_personal_best(...):\n    ...\n    self.best_position_list.append(self.best_position)\n</code></pre> <ul> <li>global best position at each iteration</li> </ul> <pre><code>if __init__ == '__main__':\n  # parameter initialisation\n  ...\n  global_best_position_list = []\n  ...\n        global_best_position = ...\n    global_best_position_list.append(global_best_position) # take note on the indentation\n    # generate beta randomly for current iteration\n    ...\n</code></pre> </li> <li> <p>Visualise the progression of these variables by adding the following code to the end of the <code>__main__</code> block.</p> <pre><code>[pos_fig, position_axes] = plt.subplots(4,1,sharex=True)\nposition_axes[0].set_title(\"Position of each particle\")\nposition_axes[1].set_title(\"Fitness of each particle\")\nposition_axes[2].set_title(\"Boxplot of position at each iteration\")\nposition_axes[3].set_title(\"Boxplot of fitness at each iteration\")\nposition_axes[3].set_xlabel(\"Iteration\")\n\n[vel_fig, velocity_axes] = plt.subplots(2,1,sharex=True)\nvelocity_axes[0].set_title(\"Velocity of each particle\")\nvelocity_axes[1].set_title(\"Boxplot for velocity at each iteration\")\nvelocity_axes[1].set_xlabel(\"Iteration\")\n\n[p_best_fig, personal_best_axes] = plt.subplots(4,1,sharex=True)\npersonal_best_axes[0].set_title(\"Personal best position of each particle\")\npersonal_best_axes[1].set_title(\"Personal best fitness of each particle\")\npersonal_best_axes[2].set_title(\"Boxplot of personal best position at each iteration\")\npersonal_best_axes[3].set_title(\"Boxplot of personal best fitness at each iteration\")\npersonal_best_axes[3].set_xlabel(\"Iteration\")\n\n[g_best_fig, global_best_axes] = plt.subplots(2,1,sharex=True)\nglobal_best_axes[0].set_title(\"Global best position\")\nglobal_best_axes[1].set_title(\"Fitness for global best position\")\nglobal_best_axes[1].set_xlabel(\"Iteration\")\n\nfor particle in particles:\n  iteration_list = list(range(len(particle.position_list)))\n  position_axes[0].plot(iteration_list, particle.position_list, '-o')\n  position_axes[1].plot(iteration_list, [fit_fcn(x) for x in particle.position_list], '-o')\n\n  velocity_axes[0].plot(iteration_list, particle.velocity_list, '-o')\n\n  personal_best_axes[0].plot(iteration_list[:-1], particle.best_position_list, '-o')\n  personal_best_axes[1].plot(iteration_list[:-1], [fit_fcn(x) for x in particle.best_position_list], '-o')\n\nposition_axes[2].boxplot([[p.position_list[i] for p in particles] for i in iteration_list], positions=iteration_list)\nposition_axes[3].boxplot([[fit_fcn(p.position_list[i]) for p in particles] for i in iteration_list], positions=iteration_list)\n\nvelocity_axes[1].boxplot([[p.velocity_list[i] for p in particles] for i in iteration_list], positions=iteration_list)\n\npersonal_best_axes[2].boxplot([[p.best_position_list[i] for p in particles] for i in iteration_list[:-1]], positions=iteration_list[:-1])\npersonal_best_axes[3].boxplot([[fit_fcn(p.best_position_list[i]) for p in particles] for i in iteration_list[:-1]], positions=iteration_list[:-1])\n\nglobal_best_axes[0].plot(iteration_list[:-1], global_best_position_list, '-o')\nglobal_best_axes[1].plot(iteration_list[:-1], [fit_fcn(x) for x in global_best_position_list], '-o')\n</code></pre> </li> </ol>"},{"location":"archive/202301/lab4-particle-swarm-optimisation/#exercise","title":"Exercise","text":"<ol> <li> <p>Multiply the velocity memory, \\(v_i(t)\\), with a value between 0 and 1, let's say 0.5. How does the process change? This is the effect of inertia weight.</p> </li> <li> <p>Reduce the value of \\(\\alpha_1\\) to 0.05 while maintaining \\(\\alpha_2\\) at 0.1 and investigate the effect. </p> </li> <li> <p>Reduce the value of \\(\\alpha_1\\) to 0. How does this affect the result?</p> </li> <li> <p>Modify such that \\(\\alpha_1\\) is larger than \\(\\alpha_2\\). What's the effect?</p> </li> <li> <p>How may you modify the formulae for particles with two variables, in which the fitness function is defined as \\(f(x,y) = x^2 + y^2\\)? </p> </li> </ol>"},{"location":"archive/202301/lab4-particle-swarm-optimisation/#report","title":"Report","text":"<p>Submit a report detailing the process you have gone through and the observations you have made.</p>"},{"location":"archive/202301/lab5-decision-tree/","title":"Lab 5: Decision Tree","text":""},{"location":"archive/202301/lab5-decision-tree/#lab-learning-outcomes","title":"Lab learning outcomes","text":"<p>After completing this lab, the students are able to</p> <ul> <li>construct decision tree using CART learning algorithm with the <code>scikit-learn</code> Python library.</li> </ul>"},{"location":"archive/202301/lab5-decision-tree/#datasets","title":"Datasets","text":"<ol> <li> <p>The iris dataset will be used for classification, and the diabetes dataset for regression.</p> <pre><code>from sklearn import datasets\nimport pandas as pd\niris = datasets.load_iris()\niris = {\n  'attributes': pd.DataFrame(iris.data, columns=iris.feature_names),\n  'target': pd.DataFrame(iris.target, columns=['species']),\n  'targetNames': iris.target_names\n}\ndiabetes = datasets.load_diabetes()\ndiabetes = {\n  'attributes': pd.DataFrame(diabetes.data, columns=diabetes.feature_names),\n  'target': pd.DataFrame(diabetes.target, columns=['diseaseProgression'])\n}\n</code></pre> </li> <li> <p>Split the datasets into 80-20 for train-test proportion.</p> <pre><code>from sklearn.model_selection import train_test_split\nfor dt in [iris, diabetes]:\n  x_train, x_test, y_train, y_test = train_test_split(dt['attributes'], dt['target'], test_size=0.2, random_state=1)\n  dt['train'] = {\n    'attributes': x_train,\n    'target': y_train\n  }\n  dt['test'] = {\n  'attributes': x_test,\n  'target': y_test\n  }\n</code></pre> <p>Note: Be reminded that <code>random_state</code> is used to reproduce the same \"random\" split of the data whenever the function is called. To produce randomly splitted data every time the function is called, remove the <code>random_state</code> argument.</p> </li> </ol> <p>How do we access the training input data for the iris dataset?</p>"},{"location":"archive/202301/lab5-decision-tree/#decision-tree","title":"Decision tree","text":"<p>Decision tree models and algorithms are provided by the <code>scikit-learn</code> as the class <code>sklearn.tree.DecisionTreeClassifier</code> for classification, and <code>sklearn.tree.DecisionTreeRegressor</code> for regression.</p>"},{"location":"archive/202301/lab5-decision-tree/#classification","title":"Classification","text":"<ol> <li> <p>Import the class for decision tree classifier.     <pre><code>from sklearn.tree import DecisionTreeClassifier\n</code></pre></p> </li> <li> <p>Instantiate an object of <code>DecisionTreeClassifier</code> class with gini impurity as the split criterion.     <pre><code>dtc = DecisionTreeClassifier(criterion='gini')\n</code></pre></p> </li> <li> <p>Train the classifier with the training data. We will use all the input attributes.     <pre><code>dtc.fit(iris['train']['attributes'], iris['train']['target'])\n</code></pre></p> </li> <li> <p><code>.predict</code> function is used to predict the species of the testing data.     <pre><code>predicts = dtc.predict(iris['test']['attributes'])\n</code></pre></p> </li> <li> <p>Comparing the predicted value and the target value of the test data.     <pre><code>print(pd.DataFrame(list(zip(iris['test']['target'].species,predicts)), columns=['target', 'predicted']))\n</code></pre></p> </li> <li> <p>Calculate the accuracy of the predicted value.     <pre><code>accuracy = dtc.score(iris['test']['attributes'],iris['test']['target'].species)\nprint(f'Accuracy: {accuracy:.4f}')\n</code></pre></p> </li> <li> <p>Decision tree visualisation</p> <ol> <li> <p>Import the <code>matplotlib.pyplot</code> library and the function to visualise the tree.     <pre><code>import matplotlib.pyplot as plt\nfrom sklearn.tree import plot_tree\n</code></pre></p> </li> <li> <p>Visualise the decision tree model.     <pre><code>plt.figure(figsize=[10,10])\ntree = plot_tree(dtc, feature_names=iris['attributes'].columns.tolist(), \n                 class_names=iris['targetNames'], filled=True, rounded=True)\n</code></pre></p> </li> </ol> </li> </ol> <p>The maximum depth of a decision tree can be defined by adding the <code>max_depth=...</code> argument to the <code>DecisionTreeClassifier(...)</code> object instantiation. To allow unlimited maximum depth, pass <code>max_depth=None</code>.</p> <p>Create a loop to compare the accuracy of the prediction with different maximum depths. In every iteration, you should calculate both the accuracy on the training data and the accuracy on the testing data. The comparison should be shown in a graph with <code>max_depth</code> as the horizontal axis and accuracy as the vertical axis. Two lines should be displayed on the graph with one line for training accuracy and the other testing accuracy.</p>"},{"location":"archive/202301/lab5-decision-tree/#visualisation-of-decision-surface","title":"Visualisation of decision surface","text":"<p>This section explains the method to visualise a decision tree on a graph. To do so we will focus on using two input attributes, sepal length and sepal width, i.e. the first two columns.</p> <ol> <li> <p>Instantiate the classifier without defining the maximum depth and train the model.     <pre><code>dtc = DecisionTreeClassifier()\ninput_cols = iris['train']['attributes'].columns[:2].tolist()\ndtc.fit(iris['train']['attributes'][input_cols], iris['train']['target'].species)\n</code></pre></p> </li> <li> <p>Plot the decision tree.     <pre><code>plt.figure(figsize=[50,50])\nplot_tree(dtc, feature_names=input_cols, \n          class_names=iris['targetNames'], filled=True, rounded=True)\nplt.savefig('classificationDecisionTreeWithNoMaxDepth.png')\n</code></pre></p> </li> <li> <p>Prepare the colormaps.     <pre><code>from matplotlib import cm\nfrom matplotlib.colors import ListedColormap\ncolormap = cm.get_cmap('tab20')\ncm_dark = ListedColormap(colormap.colors[::2])\ncm_light = ListedColormap(colormap.colors[1::2])\n</code></pre></p> </li> <li> <p>Calculating the decision surface.     <pre><code>import numpy as np\nx_min = iris['attributes'][input_cols[0]].min()\nx_max = iris['attributes'][input_cols[0]].max()\nx_range = x_max - x_min\nx_min = x_min - 0.1 * x_range\nx_max = x_max + 0.1 * x_range\ny_min = iris['attributes'][input_cols[1]].min()\ny_max = iris['attributes'][input_cols[1]].max()\ny_range = y_max - y_min\ny_min = y_min - 0.1 * y_range\ny_max = y_max + 0.1 * y_range\nxx, yy = np.meshgrid(np.arange(x_min, x_max, .01*x_range), \n                    np.arange(y_min, y_max, .01*y_range))\nz = dtc.predict(list(zip(xx.ravel(), yy.ravel())))\nz = z.reshape(xx.shape)\n</code></pre></p> </li> <li> <p>Plot the decision surface.     <pre><code>plt.figure()\nplt.pcolormesh(xx, yy, z, cmap=cm_light)\n</code></pre></p> </li> <li> <p>Plot the training and testing data.     <pre><code>plt.scatter(iris['train']['attributes'][input_cols[0]],   \n            iris['train']['attributes'][input_cols[1]], \n            c=iris['train']['target'].species, cmap=cm_dark, s=200,\n            label='Training data', edgecolor='black', linewidth=1)\nplt.scatter(iris['test']['attributes'][input_cols[0]], \n            iris['test']['attributes'][input_cols[1]], \n            c=iris['test']['target'].species, cmap=cm_dark, s=200,\n            label='Testing data', edgecolor='black', linewidth=1,\n            marker='*')\ntrain_acc = dtc.score(iris['train']['attributes'][input_cols], \n                      iris['train']['target'].species)\ntest_acc = dtc.score(iris['test']['attributes'][input_cols], \n                    iris['test']['target'].species)\nplt.title(f'training: {train_acc:.3f}, testing: {test_acc:.3f}')\nplt.xlabel(input_cols[0])\nplt.ylabel(input_cols[1])\nplt.legend()\n</code></pre></p> </li> </ol> <p>You may not be able to see anything on one of the graph of the decision tree because the figure size is set to be larger than the screen size. However, the tree is saved to a png file in the same folder as your code.</p>"},{"location":"archive/202301/lab5-decision-tree/#overfitting","title":"Overfitting","text":"<p>Now, train a decision tree classifier of <code>max_depth=3</code>with the two input attributes used in the previous section, sepal length and sepal width.</p> <p>Plot the decision surface for this classifier after the training. Compare the decision surface, training accuracy, and testing accuracy between this model and the model in the previous section. </p> <p>Discuss the comparison between the decision tree from previous section and that of <code>max_depth=3</code> from the aspect of overfitting/generalisation.</p>"},{"location":"archive/202301/lab5-decision-tree/#regression","title":"Regression","text":"<p>Regression using decision tree can be achieved by using the <code>DecisionTreeRegressor</code> class in <code>sklearn.tree</code>. Instantiate a regressor class and train the regressor with the training data using all the input attributes.</p> <p>Predict the disease progression of the testing data, and determine the accuracy of the prediction.</p> <p>Create a plot of prediction accuracies against maximum depths of the decision tree for both training data and testing data.</p>"},{"location":"archive/202301/lab5-decision-tree/#visualisation-of-decision-surface_1","title":"Visualisation of decision surface","text":"<p>This section explains the method to visualise a decision tree on a graph. To do so we will focus on using two input attributes, <code>age</code> and <code>bmi</code>.</p> <ol> <li> <p>Instantiate the classifier without defining the maximum depth and train the model.     <pre><code>dtr = DecisiontTreeRegressor()\ninput_cols = ['age', 'bmi']\ndtr.fit(diabetes['train']['attributes'][input_cols], \n        diabetes['train']['target'].diseaseProgression)\n</code></pre></p> </li> <li> <p>Plot the decision tree.     <pre><code>plt.figure(figsize=[50,50])\nplot_tree(dtr, feature_names=input_cols, filled=True, rounded=True)\nplt.savefig('regressionDecisionTreeWithNoMaxDepth.png')\n</code></pre></p> </li> <li> <p>Prepare the colormaps.     <pre><code>from matplotlib import cm\ndia_cm = cm.get_cmap('Reds')\n</code></pre></p> </li> <li> <p>Create the decision surface.     <pre><code>import numpy as np\nx_min = diabetes['attributes'][input_cols[0]].min()\nx_max = diabetes['attributes'][input_cols[0]].max()\nx_range = x_max - x_min\nx_min = x_min - 0.1 * x_range\nx_max = x_max + 0.1 * x_range\ny_min = diabetes['attributes'][input_cols[1]].min()\ny_max = diabetes['attributes'][input_cols[1]].max()\ny_range = y_max - y_min\ny_min = y_min - 0.1 * y_range\ny_max = y_max + 0.1 * y_range\nxx, yy = np.meshgrid(np.arange(x_min, x_max, .01*x_range), \n                    np.arange(y_min, y_max, .01*y_range))\nz = dtr.predict(list(zip(xx.ravel(), yy.ravel())))\nz = z.reshape(xx.shape)\n</code></pre></p> </li> <li> <p>Plot the decision surface     <pre><code>plt.figure()\nplt.pcolormesh(xx, yy, z, cmap=dia_cm)\n</code></pre></p> </li> <li> <p>Plot the training and testing data.     <pre><code>plt.scatter(diabetes['train']['attributes'][input_cols[0]],          \n            diabetes['train']['attributes'][input_cols[1]], \n            c=diabetes['train']['target'].diseaseProgression, \n            label='Training data', cmap=dia_cm, \n            edgecolor='black', linewidth=1, s=150)\nplt.scatter(diabetes['test']['attributes'][input_cols[0]],   \n            diabetes['test']['attributes'][input_cols[1]], \n            c=diabetes['test']['target'].diseaseProgression, marker='*', \n            label='Testing data', cmap=dia_cm, \n            edgecolor='black', linewidth=1, s=150)\nplt.xlabel(input_cols[0])\nplt.ylabel(input_cols[1])\nplt.legend()\nplt.colorbar()\n</code></pre></p> </li> </ol>"},{"location":"archive/202301/lab5-decision-tree/#overfitting_1","title":"Overfitting","text":"<p>Compare the decision tree regressor in the previous model with a decision tree regressor of a small maximum depth and discuss overfitting using the decision surface, training accuracy, and testing accuracy.</p>"},{"location":"archive/202301/lab5-decision-tree/#report","title":"Report","text":"<p>Submit a written report that describes the considerations while writing the scripts, the answers to the above questions, and the problems you encountered in the process. Include your script in the written report as an appendix.</p>"},{"location":"archive/202301/pre-lab/","title":"Pre-lab: Basic Python","text":""},{"location":"archive/202301/pre-lab/#objective","title":"Objective","text":"<p>To understand basic syntax of Python programming language.</p>"},{"location":"archive/202301/pre-lab/#declare-a-variable","title":"Declare a variable","text":"<p>Python is strongly and dynamically typed.</p> <p>Strongly typed means the type of a variable does not change unexpectedly. When a variable is defined as a string with only numerical digits, it stays string, it doesn\u2019t become an integer or number.</p> <p>Dynamically typed means the type of a variable can change when a value of a different type is assigned to the variable.</p> <p>As Python is dynamically typed, we do not need to specify a type when we declare a variable. We just assign a value to the variable.</p> <ol> <li> <p>Define a variable named <code>val</code> and assign the value <code>'a'</code> to the variable.</p> <pre><code>val = 'a'\n</code></pre> <p>The type of the variable can be viewed in the variable explorer.</p> </li> <li> <p>Continue from the previous code block, assign the value <code>1</code> to the same variable. The variable will now be of type <code>int</code> instead of type <code>str</code>.</p> <pre><code>val = 1\n</code></pre> </li> </ol>"},{"location":"archive/202301/pre-lab/#array-manipulation","title":"Array manipulation","text":"<ol> <li> <p>Array in Python can be declared using a set of square brackets (<code>[...]</code>).</p> </li> <li> <p>To assign a variable with an empty array,</p> <pre><code>arr = []\n</code></pre> </li> <li> <p>To define an array with a series of numbers,</p> <pre><code>arr = [1,2,3,4,5]\n</code></pre> </li> <li> <p>To define an array with a series of alphabets,</p> <pre><code>arr = ['a','b','c','d','e']\n</code></pre> </li> <li> <p>An array can also be defined with values of mixed types.</p> <pre><code>arr = [1,'a',2,'b',3,'c']\n</code></pre> </li> <li> <p>Python arrays (or more commonly known as lists) are zero indexed arrays; it means to access the first element in the array <code>arr</code>,</p> <pre><code># in IPython console\narr[0] # gives the output of 1\narr[1] # gives the output of 'a'\n</code></pre> </li> <li> <p>Python arrays also support negative indexing; this means to get the last element in the array <code>arr</code>,</p> <pre><code># in IPython console\narr[-1] # gives the output of 'c'\n</code></pre> </li> <li> <p>Colon (<code>:</code>) can be used to extract multiple elements from an array. Maximum two (2) colons can be used for indexing/slicing an array. <code>arr[0:5:2]</code> The value before the first colon is the starting index, the value after the first colon is the ending index (exclusive), the value after the second colon is the number of steps. </p> <p>If the first value is empty, it is assumed as <code>0</code>.</p> <p>If the second value is empty, it is assumed as the length of the array, i.e. up till the last element in the array.</p> <p>If the third value is empty, it is assumed as <code>1</code>.</p> <pre><code># in IPython console\narr\n# [1, 'a', 2, 'b', 3, 'c']\narr[1:5]\n# ['a', 2, 'b', 3]\narr[1:5:2]\n# ['a', 'b']\narr[:3]\n# [1, 'a', 2]\narr[4:]\n# [3, 'c']\narr[2:-2]\n# [2, 'b']\narr[4:1]\n# []\narr[4:1:-1]\n# [3, 'b', 2] --&gt; slice in the reverse order\n</code></pre> </li> </ol>"},{"location":"archive/202301/pre-lab/#add-an-element-to-the-end-of-an-array","title":"Add an element to the end of an array","text":"<pre><code># in IPython console\narr.append(4)\narr\n# [1, 'a', 2, 'b', 3, 'c', 4]\n</code></pre>"},{"location":"archive/202301/pre-lab/#add-multiple-elements-to-the-end-of-an-array","title":"Add multiple elements to the end of an array","text":"<pre><code># in IPython console\narr.extend(['d',5,'e'])\narr\n# [1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n</code></pre>"},{"location":"archive/202301/pre-lab/#assign-a-value-to-a-specific-index","title":"Assign a value to a specific index","text":"<pre><code># in IPython console\narr[0] = 0\narr\n# [0, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n</code></pre>"},{"location":"archive/202301/pre-lab/#insert-an-element-at-a-specific-index","title":"Insert an element at a specific index","text":"<pre><code># in IPython console\narr.insert(1,1)\narr\n# [0, 1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n</code></pre>"},{"location":"archive/202301/pre-lab/#remove-an-element-at-a-specific-index","title":"Remove an element at a specific index","text":"<pre><code># in IPython console\ndel arr[0]\narr\n# [1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n</code></pre>"},{"location":"archive/202301/pre-lab/#combining-arrays","title":"Combining arrays","text":"<p><code>zip</code> can be used to combine two or more arrays.</p> <pre><code># in editor\njoint_arr = list(zip([1,2,3], ['a','b','c']))\n</code></pre> <pre><code># in IPython console\njoint_arr\n# [(1,'a'),(2,'b'),(3,'c')]\n</code></pre>"},{"location":"archive/202301/pre-lab/#loops","title":"Loops","text":"<ol> <li> <p>Python supports <code>for</code> and <code>while</code> loops.</p> </li> <li> <p>To loop through every element in the array <code>arr</code> and print them to the console,</p> <pre><code>for a in arr:\n  print(a)\n# 1\n# a\n# 2\n# ...\n</code></pre> <p><code>for a in arr</code>: loops through all elements in <code>arr</code> and in each loop, an element in <code>arr</code> is assigned to the variable <code>a</code>.</p> </li> <li> <p>Note that in most other programming languages, code blocks are separated with delimiters such as the curly brackets (<code>{}</code>). This is not the case in Python. Code blocks in Python are defined by their indentation and normally initiated with a colon(<code>:</code>). </p> <p>For example,</p> <pre><code>for a in arr:\n  print(a)\nprint(arr)\n</code></pre> <p><code>print(a)</code> is the command to be executed in each loop.</p> <p><code>print(arr)</code> is only executed after the <code>for</code> loop is completed.</p> <pre><code>for a in arr:\n  print(a)\n  print(arr)\n</code></pre> <p>In this case, <code>print(arr)</code> is executed in each loop.</p> </li> <li> <p>Using <code>zip</code> we can loop through two arrays at once.</p> <pre><code>for item in zip(['a','b','c','d'],['artificial','breadth','cost','depth']):\n  print(item[0] + ' for ' + item[1])\n</code></pre> </li> <li> <p><code>enumerate</code> is useful in obtaining the index of the element in the array.</p> <pre><code>for (index, item) in enumerate(['a','b','c','d']):\n  print('Index of ' + item + ' is: ' + str(index))\n</code></pre> </li> <li> <p>Looping through a dictionary (<code>dict</code>) can also be done easily.</p> <pre><code>x_dict = {\n  'd': 'depth',\n  'e': 'estimation',\n  'f': 'frontier'\n}\nfor key,value in x_dict.items():\n  print(key + ' for ' + value)\n</code></pre> </li> <li> <p><code>while</code> loops can be defined similarly.</p> <pre><code>x = 0\nwhile x != 10: \n  x += 1\n  print(x)\nprint('while loop is completed')\n</code></pre> </li> <li> <p>The following example introduces nested array and multiple assignments.</p> <pre><code>arr = [['a',1],['b',2],['c',3],['d',4],['e',5],['f',6]]\nfor [a,n] in arr:\n  print(str(a) + ' is ' + str(n))\n</code></pre> </li> </ol>"},{"location":"archive/202301/pre-lab/#conditions","title":"Conditions","text":"<ol> <li> <p>The following operators can be used for conditional testing:</p> Operator Definition <code>==</code> Equivalence <code>!=</code> Inequivalence <code>&lt;</code> Less than <code>&lt;=</code> Less than or equal to <code>&gt;</code> Greater than <code>&gt;=</code> Greater than or equal to </li> <li> <p>Python also supports text operator for conditional testing:</p> Operator Definition Example (symbolic) Example (text) <code>is</code> Equivalence <code>a == 1</code> <code>a is 1</code> <code>not</code> Inequivalence <code>a != 1</code> <code>a is not 1</code>  or <code>not (a is 1)</code>  or <code>not a is 1</code>  or <code>not(a == 1)</code> </li> <li> <p>Combining two conditions can also be done with text operators <code>and</code> and <code>or</code>.</p> Symbolic operator Text operator <code>&amp;</code> <code>and</code> <code>|</code> <code>or</code> </li> </ol>"},{"location":"archive/202301/pre-lab/#user-defined-functions","title":"User-defined functions","text":"<ol> <li> <p>To define a custom function with the name of <code>custom_fcn</code>,</p> <pre><code>def custom_fcn():\n  print('This is a custom function to display custom message')\n</code></pre> </li> <li> <p>To call the function,</p> <pre><code>custom_fcn()\n# This is a custom function to display custom message\n</code></pre> </li> </ol>"},{"location":"archive/202301/pre-lab/#user-defined-functions-with-input-arguments","title":"User-defined functions with input arguments","text":"<ol> <li> <p>To define a custom function with input arguments,</p> <pre><code>def custom_fcn(msg):\n  print('This is a custom function to display ' + msg)\n</code></pre> </li> <li> <p>The function can be called by</p> <pre><code>custom_fcn('new message')\n# This is a custom function to display new message\n</code></pre> </li> </ol>"},{"location":"archive/202301/pre-lab/#user-defined-functions-with-optional-input-arguments","title":"User-defined functions with optional input arguments","text":"<ol> <li> <p>To define a custom function with optional input arguments, we just need to provide the default value to the optional input arguments.</p> <pre><code>def custom_fcn(msg = 'default message'):\n  print('This is a custom function to display ' + msg)\n</code></pre> </li> <li> <p>The input arguments can also be specified as named inputs.</p> <pre><code>custom_fcn(msg='new message')\n# This is a custom function to display new message\n</code></pre> </li> </ol>"},{"location":"archive/202301/pre-lab/#exercise","title":"Exercise","text":"<ol> <li> <p>Create a new file in Spyder. Define a variable named <code>friends</code> such that it is a nested array in which contains the name, home country, and home state/province of 10 of your friends (real or virtual). For example,</p> <pre><code>friends = [[\"James\", \"Malaysia\", \"Malacca\"], [\"Goh\", \"Australia\", \"Brisbane\"], [\"Don\", \"Malaysia\", \"Pahang\"]]\n</code></pre> </li> <li> <p>Create a function in the same file with three (3) optional input arguments, <code>name</code>, <code>home_country</code>, <code>home_state</code>.</p> <pre><code>def filterFriend(name=\"\", home_country=\"\", home_state=\"\"):\n  ...\n  return filtered\n</code></pre> <p>This function will filter <code>friends</code> based on the input arguments provided. The function will ignore the input argument if it has empty string, i.e. <code>\"\"</code>. If any of the input arguments is provided, the function will find the friends whose detail(s) matches the input.</p> <p>For example, </p> <p><code>filterFriend(name=\"James\")</code> will return <code>[[\"James\", \"Malaysia\", \"Malacca\"]]</code></p> <p><code>filterFriend(home_country=\"Malaysia\")</code> will return <code>[[\"James\", \"Malaysia\", \"Malacca\"], [\"Don\", \"Malaysia\", \"Pahang\"]]</code>.</p> </li> </ol>"},{"location":"archive/202401/get-start/","title":"Getting started","text":"<p>The labs for ETC2073 Artificial Intelligence will be using Python as the programming language. The Anaconda distribution of Python is recommended, however, if you are familiar and comfortable with the vanilla distribution of Python. For those who have not installed Python in their machine, proceed to next session. This page only covers the installation of the Anaconda platform as, in my opinion, it is more beginner friendly in terms of installing packages and encapsulating environments.</p>"},{"location":"archive/202401/get-start/#installation","title":"Installation","text":"<ol> <li> <p>Download the Anaconda installer with Python 3 for your system from https://www.anaconda.com/download.</p> </li> <li> <p>Use the graphical installer to install Anaconda.</p> </li> </ol>"},{"location":"archive/202401/get-start/#launching-ide","title":"Launching IDE","text":"<p>You will be using the Spyder IDE for Python. Feel free to use other IDE or code editor with terminal if that's your preference.</p> <ol> <li> <p>Start the Anaconda Navigator from your application list.</p> </li> <li> <p>From Anaconda <code>base</code> environment, launch Spyder IDE.</p> </li> <li> <p>The Spyder IDE consists of three parts: the editor, the variable explorer, and the IPython Console.</p> </li> <li> <p>The editor is where you write your codes.</p> </li> <li> <p>The variable explorer shows the value of the variable after running the code.</p> </li> <li> <p>The IPython console allows you to execute commands, interact with the running code, and display visualisation.</p> </li> <li> <p>After the code is written in the editor, you can execute the code using F5 to run file.</p> </li> <li> <p>Then the variables and their values can be found in the variable explorer.</p> </li> </ol>"},{"location":"archive/202401/lab1-introductory-python/","title":"Lab 1: Introduction to Python","text":""},{"location":"archive/202401/lab1-introductory-python/#objective","title":"Objective","text":"<p>To understand basic syntax of Python programming language.</p>"},{"location":"archive/202401/lab1-introductory-python/#declare-a-variable","title":"Declare a variable","text":"<p>Python is strongly and dynamically typed.</p> <p>Strongly typed means the type of a variable does not change unexpectedly. When a variable is defined as a string with only numerical digits, it stays string, it doesn\u2019t become an integer or number.</p> <p>Dynamically typed means the type of a variable can change when a value of a different type is assigned to the variable.</p> <p>As Python is dynamically typed, we do not need to specify a type when we declare a variable. We just assign a value to the variable.</p> <ol> <li> <p>Define a variable named <code>val</code> and assign the value <code>'a'</code> to the variable.</p> <pre><code>val = 'a'\n</code></pre> <p>The type of the variable can be viewed in the variable explorer.</p> </li> <li> <p>Continue from the previous code block, assign the value <code>1</code> to the same variable. The variable will now be of type <code>int</code> instead of type <code>str</code>.</p> <pre><code>val = 1\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab1-introductory-python/#array-manipulation","title":"Array manipulation","text":"<ol> <li> <p>Array in Python can be declared using a set of square brackets (<code>[...]</code>).</p> </li> <li> <p>To assign a variable with an empty array,</p> <pre><code>arr = []\n</code></pre> </li> <li> <p>To define an array with a series of numbers,</p> <pre><code>arr = [1,2,3,4,5]\n</code></pre> </li> <li> <p>To define an array with a series of alphabets,</p> <pre><code>arr = ['a','b','c','d','e']\n</code></pre> </li> <li> <p>An array can also be defined with values of mixed types.</p> <pre><code>arr = [1,'a',2,'b',3,'c']\n</code></pre> </li> <li> <p>Python arrays (or more commonly known as lists) are zero indexed arrays; it means to access the first element in the array <code>arr</code>,</p> <pre><code># in IPython console\narr[0] # gives the output of 1\narr[1] # gives the output of 'a'\n</code></pre> </li> <li> <p>Python arrays also support negative indexing; this means to get the last element in the array <code>arr</code>,</p> <pre><code># in IPython console\narr[-1] # gives the output of 'c'\n</code></pre> </li> <li> <p>Colon (<code>:</code>) can be used to extract multiple elements from an array. Maximum two (2) colons can be used for indexing/slicing an array. <code>arr[0:5:2]</code> The value before the first colon is the starting index, the value after the first colon is the ending index (exclusive), the value after the second colon is the number of steps. </p> <p>If the first value is empty, it is assumed as <code>0</code>.</p> <p>If the second value is empty, it is assumed as the length of the array, i.e. up till the last element in the array.</p> <p>If the third value is empty, it is assumed as <code>1</code>.</p> <pre><code># in IPython console\narr\n# [1, 'a', 2, 'b', 3, 'c']\narr[1:5]\n# ['a', 2, 'b', 3]\narr[1:5:2]\n# ['a', 'b']\narr[:3]\n# [1, 'a', 2]\narr[4:]\n# [3, 'c']\narr[2:-2]\n# [2, 'b']\narr[4:1]\n# []\narr[4:1:-1]\n# [3, 'b', 2] --&gt; slice in the reverse order\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab1-introductory-python/#add-an-element-to-the-end-of-an-array","title":"Add an element to the end of an array","text":"<pre><code># in IPython console\narr.append(4)\narr\n# [1, 'a', 2, 'b', 3, 'c', 4]\n</code></pre>"},{"location":"archive/202401/lab1-introductory-python/#add-multiple-elements-to-the-end-of-an-array","title":"Add multiple elements to the end of an array","text":"<pre><code># in IPython console\narr.extend(['d',5,'e'])\narr\n# [1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n</code></pre>"},{"location":"archive/202401/lab1-introductory-python/#assign-a-value-to-a-specific-index","title":"Assign a value to a specific index","text":"<pre><code># in IPython console\narr[0] = 0\narr\n# [0, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n</code></pre>"},{"location":"archive/202401/lab1-introductory-python/#insert-an-element-at-a-specific-index","title":"Insert an element at a specific index","text":"<pre><code># in IPython console\narr.insert(1,1)\narr\n# [0, 1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n</code></pre>"},{"location":"archive/202401/lab1-introductory-python/#remove-an-element-at-a-specific-index","title":"Remove an element at a specific index","text":"<pre><code># in IPython console\ndel arr[0]\narr\n# [1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n</code></pre>"},{"location":"archive/202401/lab1-introductory-python/#combining-arrays","title":"Combining arrays","text":"<p><code>zip</code> can be used to combine two or more arrays.</p> <pre><code># in editor\njoint_arr = list(zip([1,2,3], ['a','b','c']))\n</code></pre> <pre><code># in IPython console\njoint_arr\n# [(1,'a'),(2,'b'),(3,'c')]\n</code></pre>"},{"location":"archive/202401/lab1-introductory-python/#loops","title":"Loops","text":"<ol> <li> <p>Python supports <code>for</code> and <code>while</code> loops.</p> </li> <li> <p>To loop through every element in the array <code>arr</code> and print them to the console,</p> <pre><code>for a in arr:\n  print(a)\n# 1\n# a\n# 2\n# ...\n</code></pre> <p><code>for a in arr</code>: loops through all elements in <code>arr</code> and in each loop, an element in <code>arr</code> is assigned to the variable <code>a</code>.</p> </li> <li> <p>Note that in most other programming languages, code blocks are separated with delimiters such as the curly brackets (<code>{}</code>). This is not the case in Python. Code blocks in Python are defined by their indentation and normally initiated with a colon(<code>:</code>). </p> <p>For example,</p> <pre><code>for a in arr:\n  print(a)\nprint(arr)\n</code></pre> <p><code>print(a)</code> is the command to be executed in each loop.</p> <p><code>print(arr)</code> is only executed after the <code>for</code> loop is completed.</p> <pre><code>for a in arr:\n  print(a)\n  print(arr)\n</code></pre> <p>In this case, <code>print(arr)</code> is executed in each loop.</p> </li> <li> <p>Using <code>zip</code> we can loop through two arrays at once.</p> <pre><code>for item in zip(['a','b','c','d'],['artificial','breadth','cost','depth']):\n  print(item[0] + ' for ' + item[1])\n</code></pre> </li> <li> <p><code>enumerate</code> is useful in obtaining the index of the element in the array.</p> <pre><code>for (index, item) in enumerate(['a','b','c','d']):\n  print('Index of ' + item + ' is: ' + str(index))\n</code></pre> </li> <li> <p>Looping through a dictionary (<code>dict</code>) can also be done easily.</p> <pre><code>x_dict = {\n  'd': 'depth',\n  'e': 'estimation',\n  'f': 'frontier'\n}\nfor key,value in x_dict.items():\n  print(key + ' for ' + value)\n</code></pre> </li> <li> <p><code>while</code> loops can be defined similarly.</p> <pre><code>x = 0\nwhile x != 10: \n  x += 1\n  print(x)\nprint('while loop is completed')\n</code></pre> </li> <li> <p>The following example introduces nested array and multiple assignments.</p> <pre><code>arr = [['a',1],['b',2],['c',3],['d',4],['e',5],['f',6]]\nfor [a,n] in arr:\n  print(str(a) + ' is ' + str(n))\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab1-introductory-python/#conditions","title":"Conditions","text":"<ol> <li> <p>The following operators can be used for conditional testing:</p> Operator Definition <code>==</code> Equivalence <code>!=</code> Inequivalence <code>&lt;</code> Less than <code>&lt;=</code> Less than or equal to <code>&gt;</code> Greater than <code>&gt;=</code> Greater than or equal to </li> <li> <p>Python also supports text operator for conditional testing:</p> Operator Definition Example (symbolic) Example (text) <code>is</code> Equivalence <code>a == 1</code> <code>a is 1</code> <code>not</code> Inequivalence <code>a != 1</code> <code>a is not 1</code>  or <code>not (a is 1)</code>  or <code>not a is 1</code>  or <code>not(a == 1)</code> </li> <li> <p>Combining two conditions can also be done with text operators <code>and</code> and <code>or</code>.</p> Symbolic operator Text operator <code>&amp;</code> <code>and</code> <code>|</code> <code>or</code> </li> </ol>"},{"location":"archive/202401/lab1-introductory-python/#user-defined-functions","title":"User-defined functions","text":"<ol> <li> <p>To define a custom function with the name of <code>custom_fcn</code>,</p> <pre><code>def custom_fcn():\n  print('This is a custom function to display custom message')\n</code></pre> </li> <li> <p>To call the function,</p> <pre><code>custom_fcn()\n# This is a custom function to display custom message\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab1-introductory-python/#user-defined-functions-with-input-arguments","title":"User-defined functions with input arguments","text":"<ol> <li> <p>To define a custom function with input arguments,</p> <pre><code>def custom_fcn(msg):\n  print('This is a custom function to display ' + msg)\n</code></pre> </li> <li> <p>The function can be called by</p> <pre><code>custom_fcn('new message')\n# This is a custom function to display new message\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab1-introductory-python/#user-defined-functions-with-optional-input-arguments","title":"User-defined functions with optional input arguments","text":"<ol> <li> <p>To define a custom function with optional input arguments, we just need to provide the default value to the optional input arguments.</p> <pre><code>def custom_fcn(msg = 'default message'):\n  print('This is a custom function to display ' + msg)\n</code></pre> </li> <li> <p>The input arguments can also be specified as named inputs.</p> <pre><code>custom_fcn(msg='new message')\n# This is a custom function to display new message\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab1-introductory-python/#exercise","title":"Exercise","text":"<ol> <li> <p>Create a new file in Spyder. Define a variable named <code>friends</code> such that it is a nested array in which contains the name, home country, and home state/province of 10 of your friends (real or virtual). For example,</p> <pre><code>friends = [[\"James\", \"Malaysia\", \"Malacca\"], [\"Goh\", \"Australia\", \"Brisbane\"], [\"Don\", \"Malaysia\", \"Pahang\"]]\n</code></pre> </li> <li> <p>Create a function in the same file with three (3) optional input arguments, <code>name</code>, <code>home_country</code>, <code>home_state</code>.</p> <pre><code>def filterFriend(name=\"\", home_country=\"\", home_state=\"\"):\n  ...\n  return filtered\n</code></pre> <p>This function will filter <code>friends</code> based on the input arguments provided. The function will ignore the input argument if it has empty string, i.e. <code>\"\"</code>. If any of the input arguments is provided, the function will find the friends whose detail(s) matches the input.</p> <p>For example, </p> <p><code>filterFriend(name=\"James\")</code> will return <code>[[\"James\", \"Malaysia\", \"Malacca\"]]</code></p> <p><code>filterFriend(home_country=\"Malaysia\")</code> will return <code>[[\"James\", \"Malaysia\", \"Malacca\"], [\"Don\", \"Malaysia\", \"Pahang\"]]</code>.</p> </li> </ol>"},{"location":"archive/202401/lab2-fuzzy/","title":"Lab 2: Fuzzy Systems","text":""},{"location":"archive/202401/lab2-fuzzy/#lab-learning-outcomes","title":"Lab learning outcomes","text":"<p>After completing this lab, the students are able to</p> <ul> <li>construct a Mamdani fuzzy system using the <code>scikit-fuzzy</code> Python library and</li> <li>evaluate the result of the constructed fuzzy system.</li> </ul>"},{"location":"archive/202401/lab2-fuzzy/#note","title":"Note","text":"<p>Install the <code>scikit-fuzzy</code> Python library in your environment before proceeding with the lab.</p> <pre><code>conda install -c conda-forge scikit-fuzzy\n</code></pre>"},{"location":"archive/202401/lab2-fuzzy/#fuzzy-control-system-for-a-train","title":"Fuzzy control system for a train","text":"<ol> <li> <p>Consider a fuzzy control system to control the brake and throttle of a train based on the speed of the train and the distance of the train to the next stop.</p> </li> <li> <p>Import the <code>skfuzzy</code>, <code>skfuzzy.control</code>, and <code>numpy</code>.</p> <pre><code>import numpy as np\nfrom skfuzzy import control as ctrl\nfrom skfuzzy import membership as mf\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab2-fuzzy/#initialise-inputs-and-outputs","title":"Initialise inputs and outputs","text":"<ol> <li> <p>Speed and distance are the inputs of the system whereas brake and throttle are the outputs.</p> </li> <li> <p>The ranges for the variables are:</p> Variable Range Speed 0 - 85 km/h Distance 0 - 3000 m Brake 0 - 100% Throttle 0 - 100% </li> <li> <p>As the inputs will be the antecedents of the rules, construct the variables <code>speed</code> and <code>distance</code> as <code>skfuzzy.control.Antecedent</code> objects. </p> <pre><code>speed = ctrl.Antecedent(np.arange(0, 85, 0.1), 'speed')\n</code></pre> </li> <li> <p>The initialisation function for <code>skfuzzy.control.Antecedent</code> object takes 2 arguments, the first is the universe of the variable, i.e. the values the variables can take, the second is the label of the variable. The initialisation function for <code>skfuzzy.control.Consequent</code> is similar. </p> </li> <li> <p>The label and the range of the variable can be accessed using <code>.label</code> and <code>.universe</code> respectively.</p> </li> </ol> <p>Task: Initialise the variables <code>distance</code> as <code>Antecedent</code> object, and <code>brake</code> and <code>throttle</code> as <code>Consequent</code> objects. (Outputs of the system will be consequents of the rules)</p>"},{"location":"archive/202401/lab2-fuzzy/#define-membership-functions-for-fuzzy-sets-of-variables","title":"Define membership functions for fuzzy sets of variables","text":"<ol> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>speed (0 to 85 km/h)</p> Linguistic value Fit vector Stopped (1/0, 0/2) Very slow (0/1, 1/2.5, 0/4) Slow (0/2.5, 1/6.5, 0/10.5) Medium fast (0/6.5, 1/26.5, 0/46.5) Fast (0/26.5, 1/70, 1/85) </li> <li> <p>distance (0 to 3000 m)</p> Linguistic value Fit vector At (1/0, 0/2) Very near (0/1, 1/3, 0/5) Near (0/3, 1/101.5, 0/200) Medium far (0/100, 1/1550, 0/3000) Far (0/1500, 1/2250, 1/3000) </li> <li> <p>brake (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/40) Very slight (0/20, 1/50, 0/80) Slight (0/70, 1/83.5, 0/97) Medium (0/95, 1/97, 0/99) Full (0/98, 1/100) </li> <li> <p>throttle (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/2) Very slight (0/1, 1/3, 0/5) Slight (0/3, 1/16.5, 0/30) Medium (0/20, 1/50, 0/80) Full (0/60, 1/80, 1/100) </li> </ul> </li> <li> <p>The <code>skfuzzy.membership</code> module provides the following membership functions:</p> Membership function Description <code>skfuzzy.membership.dsigmf(x, b1, c1, b2, c2)</code> Difference of two fuzzy sigmoid membership functions <code>skfuzzy.membership.gauss2mf(x, mean1, ...)</code> Gaussian fuzzy membership function of two combined Gaussians <code>skfuzzy.membership.gaussmf(x, mean, sigma)</code> Gaussian fuzzy membership function <code>skfuzzy.membership.gbellmf(x, a, b, c)</code> Generalized Bell function fuzzy membership generator <code>skfuzzy.membership.piecemf(x, abc)</code> Piecewise linear membership function (particularly used in FIRE filters) <code>skfuzzy.membership.pimf(x, a, b, c, d)</code> Pi-function fuzzy membership generator <code>skfuzzy.membership.psigmf(x, b1, c1, b2, c2)</code> Product of two sigmoid membership functions <code>skfuzzy.membership.sigmf(x, b, c)</code> The basic sigmoid membership function generator <code>skfuzzy.membership.smf(x, a, b)</code> S-function fuzzy membership generator <code>skfuzzy.membership.trapmf(x, abcd)</code> Trapezoidal membership function generator <code>skfuzzy.membership.trimf(x, abc)</code> Triangular membership function generator <code>skfuzzy.membership.zmf(x, a, b)</code> Z-function fuzzy membership generator </li> <li> <p>The fit vector of a linguitic value can be assigned to a linguistic variable using</p> <pre><code>speed['stopped'] = mf.trimf(speed.universe, [0, 0, 2])\nspeed['very slow'] = mf.trimf(speed.universe, [1, 2.5, 4])\n</code></pre> <p>Task: Assign all fuzzy sets to the linguistic variables.</p> </li> <li> <p>The fuzzy set diagram of a linguistic variable can be viewed using <code>.view()</code></p> <pre><code>speed.view()\n</code></pre> <p>Task: Check if the fuzzy set diagrams match the fit vectors.</p> </li> </ol>"},{"location":"archive/202401/lab2-fuzzy/#define-rules","title":"Define rules","text":"<ol> <li> <p>The rules for this system are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Distance At Very near Near Medium far Far Speed Stopped Full brakeNo throttle Full brakeVery slight throttle Very slow Full brakeNo throttle Medium brakeVery slight throttle Slight brakeVery slight throttle Slow Full brakeNo throttle Medium brakeVery slight throttle Very slight brakeSlight throttle Medium fast Very slight brakeMedium throttle No brakeFull throttle Fast Very slight brakeMedium throttle No brakeFull throttle </p> </li> <li> <p>Rule can be defined using <code>skfuzzy.control.Rule(antecedent, consequent, label)</code>. To define the first rule, i.e. if distance is 'at' and speed is 'stopped', then full brake and no throttle, </p> <pre><code>rule1 = ctrl.Rule(distance['at'] &amp; speed['stopped'], (brake['full'], throttle['no']))\n</code></pre> <p>If the antecedent consists of multiple parts, they can be combined using operators <code>|</code> (OR), <code>&amp;</code> (AND), and <code>~</code> (NOT).</p> <p>If the consequent consists of multiple parts, they can be combined as a <code>list</code>/<code>tuple</code>.</p> <p>Task: Define all the rules. Then combine all the rules in a <code>list</code>, i.e. <code>rules = [rule1, rule2, ...]</code>.</p> </li> </ol>"},{"location":"archive/202401/lab2-fuzzy/#construct-the-fuzzy-control-system","title":"Construct the fuzzy control system","text":"<ol> <li> <p>The train control system can be constructed with</p> <pre><code>train_ctrl = ctrl.ControlSystem(rules=rules)\n</code></pre> </li> <li> <p>A <code>skfuzzy.control.ControlSystemSimulation</code> object is needed to simulate the control system to obtain the outputs given certain inputs.</p> <pre><code>train = ctrl.ControlSystemSimulation(control_system=train_ctrl)\n</code></pre> </li> <li> <p>To obtain the values for <code>brake</code> and <code>throttle</code> given that <code>speed</code> is 30 km/h and <code>distance</code> is 6 m,</p> <pre><code># define the values for the inputs\ntrain.input['speed'] = 30\ntrain.input['distance'] = 2000\n\n# compute the outputs\ntrain.compute()\n\n# print the output values\nprint(train.output)\n\n# to extract one of the outputs\nprint(train.output['brake'])\n</code></pre> </li> <li> <p>To view the results in the graph,</p> <pre><code>brake.view(sim=train)\nthrottle.view(sim=train)\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab2-fuzzy/#view-the-controloutput-space","title":"View the control/output space","text":"<ol> <li> <p>The control/output space allows us to identify if the outputs fit our expectation.</p> </li> <li> <p>Construct an empty 3D space with 100-by-100 x-y grid.</p> <pre><code>x, y = np.meshgrid(np.linspace(speed.universe.min(), speed.universe.max(), 100),\n                   np.linspace(distance.universe.min(), distance.universe.max(), 100))\nz_brake = np.zeros_like(x, dtype=float)\nz_throttle = np.zeros_like(x, dtype=float)\n</code></pre> </li> <li> <p>Loop through every point and identify the value of brake and throttle of each point. As the specified rules are not exhaustive, i.e. some input combinations do not activate any rule, we will set the output of such input combinations to be <code>float('inf')</code>.     <pre><code>for i,r in enumerate(x):\n  for j,c in enumerate(r):\n    train.input['speed'] = x[i,j]\n    train.input['distance'] = y[i,j]\n    try:\n      train.compute()\n    except:\n      z_brake[i,j] = float('inf')\n      z_throttle[i,j] = float('inf')\n    z_brake[i,j] = train.output['brake']\n    z_throttle[i,j] = train.output['throttle']\n</code></pre></p> </li> <li> <p>Plot the result in a 3D graph using the <code>matplotlib.pyplot</code> library.</p> <pre><code>import matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef plot3d(x,y,z):\n  fig = plt.figure()\n  ax = fig.add_subplot(111, projection='3d')\n\n  ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='viridis', linewidth=0.4, antialiased=True)\n\n  ax.contourf(x, y, z, zdir='z', offset=-2.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='x', offset=x.max()*1.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='y', offset=y.max()*1.5, cmap='viridis', alpha=0.5)\n\n  ax.view_init(30, 200)\n\nplot3d(x, y, z_brake)\nplot3d(x, y, z_throttle)\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab2-fuzzy/#fuzzy-tipping-recommendation-system","title":"Fuzzy tipping recommendation system","text":"<ol> <li> <p>A fuzzy expert system is designed to identify the percentage of tips a customer will give based on the service and the food the customer received.</p> </li> <li> <p>The system has service rating and food rating as inputs, and tips as output.</p> </li> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>service (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>food (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>tips (0 to 30%)</p> Linguistic value Fit vector Low (1/0, 0/15) Medium (0/0, 1/15, 0/30) High (0/15, 1/30) </li> </ul> </li> <li> <p>The rules are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Food Poor Average Good Service Poor low tips low tips medium tips Average low tips medium tips high tips Good medium tips high tips high tips </p> </li> </ol> <p>Task: Construct the fuzzy inference system.</p> <p>Task: Discuss, if you were to make at least one modification to the fuzzy tipping recommendation system, what it will be and why.</p>"},{"location":"archive/202401/lab2-fuzzy/#report","title":"Report","text":"<p>Submit a report detailing the process, results, graphs, and your observations.</p>"},{"location":"archive/202401/lab3-genetic-algorithm/","title":"Lab 3: Genetic Algorithm","text":""},{"location":"archive/202401/lab3-genetic-algorithm/#lab-learning-outcomes","title":"Lab learning outcomes","text":"<p>After completing this lab, the students are able to implement genetic algorithm to solve an optimisation problem.</p>"},{"location":"archive/202401/lab3-genetic-algorithm/#binary-to-gray-code-conversion","title":"Binary-to-gray code conversion","text":"<p>Binary string is often used in the implementation of genetic algorithm. However, the downside of using a binary code is that the Hamming distance between two adjacent values is not consistent. This situation is solved by using a Gray code in place of a binary code.</p> <ol> <li> <p><code>numpy</code> provides the function of <code>binary_repr</code> to convert a decimal value to its corresponding binary code.</p> </li> <li> <p>Create a function to take the input of a binary code and return the correponding Gray code of the binary code. </p> </li> <li> <p>Create a function to calculate the Hamming distance between two binary strings (two binary codes or two Gray codes).</p> </li> <li> <p>Consider a sequence of decimal values of <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>. Convert the sequence to a series of binary codes. Identify and plot (example of a line plot) the Hamming distances between the adjacent values.</p> </li> <li> <p>Repeat the previous step with Gray codes instead of binary codes.</p> </li> </ol>"},{"location":"archive/202401/lab3-genetic-algorithm/#genetic-algorithm","title":"Genetic algorithm","text":"<p>Consider the following problem: </p> <p>Problem</p> <p>You are given a sheet of paper with width <code>w</code> and height <code>h</code>. Your task is to cut the paper into squares of equal size. The aim of the task is to have as many squares as possible, and to have the area of each square as large as possible.</p> <ol> <li> <p>An optimisation problem can always be phrased in the form of</p> <p>to optimise ... such that it maximises/minimises ...</p> <p>In this problem, what is the parameter to be optimised and what are the parameters to be maximised or minimised?</p> </li> <li> <p>Let <code>x</code> denotes the length of the sides of a square. We need a fitness function such that higher fitness corresponds to larger number of squares and large area. If the number of squares (that can be cut out) is zero, or the area of the square is zero, the fitness will be zero. Consider the fitness function of <code>number of squares * area of a single square</code>.</p> </li> </ol> feature encoding population initialisation selection as parents crossover mutation offspring (next generation population) repeat from fitnexx calculation until termination"},{"location":"archive/202401/lab3-genetic-algorithm/#feature-encoding","title":"Feature encoding","text":"<ol> <li> <p>In this problem as we only have one feature, i.e. the side length of the square, each chromosome consists of the value of the side length of the square. We will encode the chromosome in the form of Gray code. </p> </li> <li> <p>Create two functions <code>value2gray</code> and <code>gray2value</code> to convert a decimal value to its Gray code and vice versa.</p> <pre><code>def value2gray(value):\n  # this function converts a decimal value to its gray code representation\n  ...\n  return gray\n\ndef gray2value(gray):\n  # this function converts a gray code representation to its decimal value\n  ...\n  return value\n</code></pre> </li> <li> <p>Add the following code snippet to the end of the code to test your functions.</p> <pre><code>if __name__ == \"__main__\":\n  print(value2gray(10))\n  print(gray2value(\"1001\"))\n</code></pre> <p>After running the file as a script, you should see the following output.</p> <pre><code>1111\n14\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab3-genetic-algorithm/#population-initialisation","title":"Population initialisation","text":"<ol> <li> <p>A population is randomly generated according to the defined population size. </p> </li> <li> <p>Create a function to generate randomly a population of size <code>pop_size</code> with each value lies between the range of <code>pop_min</code> to <code>pop_max</code>.</p> <pre><code>def generatePopulation(pop_size, pop_min, pop_max):\n  # this function generate the first generation randomly based on the population size and the range of the value of each chromosome\n  ...\n  return population\n</code></pre> <p>This function and all the functions created after this should be placed before the <code>if __name__ == \"__main__\":</code> code block.</p> </li> <li> <p>[Optional testing] You can test the function by changing the <code>__main__</code> code block to </p> <pre><code>if __name__ == \"__main__\":\n  print(generatePopulation(8, 0, 10))\n</code></pre> <p>The printed output should be a series of 8 chromosomes displayed as decimal values.</p> </li> </ol>"},{"location":"archive/202401/lab3-genetic-algorithm/#fitness-calculation","title":"Fitness calculation","text":"<ol> <li> <p>The fitness function was designed at the beginning of this section. Define a function that takes the input of a chromosome (as decimal value) and returns the fitness of the chromosome.</p> <p><pre><code>def calculateFitness(value):\n  # this function calculates the fitness of a chromosome from the decimal value of the chromosome\n  ...\n  return fitness\n</code></pre> 2. [Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(calculateFitness(5))\n</code></pre> <p>The printed output should be the fitness of a chromosome of value 5, which would be a decimal value larger than zero.</p> </li> </ol>"},{"location":"archive/202401/lab3-genetic-algorithm/#selection-as-parents","title":"Selection as parents","text":"<ol> <li> <p>From the list of the chromosomes, we will select the chromosome pairs as parents. As we will be using one-point crossover, each pair of parents will produce exactly two offsprings. Therefore for population size of <code>pop_size</code>, we need <code>pop_size/2</code> pairs of parents.</p> </li> <li> <p>Define a function that takes the inputs of the current population and the total number of chromosomes in current population, and returns the chromosome pairs which will act as parents. The selection process is performed with the roulette wheel selection. The same chromosome can be selected more than once.</p> <pre><code>def selectParents(chromosomes, pop_size):\n  ...\n  return parent_pairs\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(selectParents([13, 8, 14, 7], 6))\n</code></pre> <p>The printed output should be 3 parent pairs, for example, </p> <pre><code>[[13, 8], [8, 14], [13, 7]]\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab3-genetic-algorithm/#crossover","title":"Crossover","text":"<ol> <li> <p>Define a function that takes a parent pair and returns a pair of offspring after performing one-point crossover.</p> <pre><code>def crossover(parents):\n  # this function takes a parent pair and perform one-point crossover to produce a pair of offspring\n  ...\n  return offsprings\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(crossover([13, 9]))\n</code></pre> <p>The printed output should be a pair of offsprings, for example,</p> <pre><code>[10, 14]\n</code></pre> <p><code>13</code> is <code>1011</code> and <code>9</code> is <code>1101</code> in Gray code, the offsprings <code>10</code> is <code>1111</code> and <code>14</code> is <code>1001</code> in Gray code.</p> </li> </ol>"},{"location":"archive/202401/lab3-genetic-algorithm/#mutation","title":"Mutation","text":"<ol> <li> <p>Each gene in all chromosomes has the same mutation probability <code>p_mutation</code>. </p> </li> <li> <p>Define a function that takes a chromosome and the mutation probability <code>p_mutation</code> as the inputs, and returns the mutated chromosome. </p> <p><pre><code>def mutate(chromosome, p_mutation):\n  # this function mutates each gene of a chromosome based on the mutation probability\n  ...\n  return mutated\n</code></pre> 3. [Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(mutate(15, 0.1))\n</code></pre> <p>The printed output should be the mutated or unmutated chromosome, for example, <code>14</code>.</p> <p><code>15</code> is <code>1000</code> and <code>14</code> is <code>1001</code> in Gray code. In the example output, the last bit is mutated.</p> </li> </ol>"},{"location":"archive/202401/lab3-genetic-algorithm/#repeat-until-termination","title":"Repeat until termination","text":"<ol> <li> <p>The common termination criteria are the maximum number of iterations and the distance among the fitnesses of the chromosomes of the latest population.</p> </li> <li> <p>Define a function that calculates one metric to measure the distance among the fitnesses of the chromosomes, i.e. how far the fitnesses of all the chromosomes are from each other.</p> <pre><code>def findOverallDistance(chromosomes):\n  # this function takes the input of the current population and returns the overall distance among fitnesses of all chromosomes\n  ...\n  return overall_distance\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(findOverallDistance([13, 11, 14, 7]))\n</code></pre> <p>The printed output should be a decimal value that represents the overall distance of fitnesses.</p> </li> </ol>"},{"location":"archive/202401/lab3-genetic-algorithm/#combining-all-functions","title":"Combining all functions","text":"<ol> <li> <p>The functions we have created can be combined with the following code snippet to execute the genetic algorithm to solve the problem defined at the beginning of this section. Consider the width and the height of the sheet of paper to be <code>20cm</code> and <code>15cm</code>.</p> <pre><code>if __name__ == \"__main__\":\n  # main function\n  ## parameter definition\n  pop_size = 10\n  pop_min = 1 #1cm\n  pop_max = 10 #10cm\n  curr_iter = 0\n  max_iter = 100\n  min_overalldistance = 0.5\n  p_mutation = 0.05\n  ## initialise population\n  population = []\n  population.append(generatePopulation(pop_size, pop_min, pop_max))\n  while (curr_iter &lt; max_iter and findOverallDistance(population[-1]) &gt; min_overalldistance):\n    curr_iter += 1\n    ## select parent pairs\n    parents = selectParents(population[-1], len(population[-1]))\n    ## perform crossover\n    offsprings = []\n    for p in parents:\n      new_offsprings = crossover(p)\n      for o in new_offsprings:\n        offsprings.append(o)\n    ## perform mutation\n    mutated = [mutate(offspring, p_mutation) for offspring in offsprings]\n    ## update current population\n    population.append(mutated)\n</code></pre> </li> </ol> <p>Task: Consider a different fitness function than the one defined here. How does it change the outcome of the algorithm?</p>"},{"location":"archive/202401/lab3-genetic-algorithm/#report","title":"Report","text":"<p>Submit a report detailing the process, results, graphs, and your observations.</p>"},{"location":"archive/202401/lab4-particle-swarm-optimisation/","title":"Lab 4: Particle Swarm Optimisastion","text":""},{"location":"archive/202401/lab4-particle-swarm-optimisation/#lab-learning-outcomes","title":"Lab learning outcomes","text":"<p>After completing this lab, the students are able to</p> <ul> <li>develop a Python function to perform global best particle swarm optimisation.</li> </ul>"},{"location":"archive/202401/lab4-particle-swarm-optimisation/#setup-for-spyder","title":"Setup for Spyder","text":"<ol> <li> <p>If you are using Spyder for this lab, go to Tools &gt; Preferences &gt; IPython console &gt; Graphics and set Backend to Automatic.</p> </li> <li> <p>Restart kernel by going to Consoles &gt; Restart kernel.</p> </li> </ol>"},{"location":"archive/202401/lab4-particle-swarm-optimisation/#problem-to-solve","title":"Problem to solve","text":"<p>Solve the following problem using global best particle swarm optimisation:</p> <p>Problem</p> <p>Find the value of x to minimise the function \\(f(x) = (x+100)(x+50)(x)(x-20)(x-60)(x-100)\\) for \\(-100 &lt; x &lt; 100\\)</p>"},{"location":"archive/202401/lab4-particle-swarm-optimisation/#particle-swarm-optimisation","title":"Particle swarm optimisation","text":"particles initialisation personal best identification global best identification velocity calculation position update repeat from personal best identification until termination"},{"location":"archive/202401/lab4-particle-swarm-optimisation/#parameter-definition","title":"Parameter definition","text":"<ol> <li> <p>With global best particle swarm optimisaton, the position update function is given by</p> \\[x_i(t+1) = x_i(t) + v_i(t+1)\\] <p>and the velocity update function is</p> \\[v_i(t+1) = v_i(t) + \\alpha_1\\beta_1(t) \\Big( p_i(t) - x_i(t) \\Big) + \\alpha_2\\beta_2(t)\\Big(p_g(t) - x_i(t)\\Big)\\] </li> <li> <p>\u03b1<sub>1</sub> and \u03b1<sub>2</sub> are acceleration constants that are fixed throughout the algorithm. Define a small value for \u03b1<sub>1</sub> and \u03b1<sub>2</sub>, for example <code>0.1</code>.</p> <pre><code>alpha = [0.1, 0.1]\n</code></pre> </li> <li> <p>\u03b2<sub>1</sub>(t) and \u03b2<sub>2</sub>(t) are random values between <code>0</code> and <code>1</code> that are regenerated every iteration. Therefore no definition is required.</p> </li> <li> <p>Also, define the number of particles to run the algorithm with.</p> <pre><code>n_particle = 10\n</code></pre> </li> <li> <p>Place the definition of these variables in the <code>__main__</code> block.</p> <pre><code>if __name__ == '__main__':\n  alpha = [0.1, 0.1]\n  n_particle = 10\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab4-particle-swarm-optimisation/#create-a-class-for-particle","title":"Create a class for particle","text":"<ol> <li> <p>As each particle is an individual, create a <code>Particle</code> class to hold the data of the particle's current position, velocity, and personal best position.</p> <pre><code>class Particle:\n  def __init__(self, position = 0, velocity = 0):\n    self.position = position\n    self.velocity = velocity\n    self.best_position = position\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab4-particle-swarm-optimisation/#fitness-function","title":"Fitness function","text":"<ol> <li> <p>Fitness function is how we can compare different particles.</p> </li> <li> <p>As our goal is to minimise f(x) as stated in the beginning, we will use f(x) as our fitness function.</p> </li> <li> <p>By using f(x) in minimisation problem, it implies that the lower the value of f(x), the better the particle it is.</p> </li> <li> <p>The value of x is the position of the particle.</p> </li> <li> <p>Define the fitness function as a Python function.</p> <pre><code>def fit_fcn(position):\n  ...\n  return fitness\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab4-particle-swarm-optimisation/#initialise-particles","title":"Initialise particles","text":"<ol> <li> <p>Particles are initialised with random positions within the constraints. </p> </li> <li> <p>At initialisation, we may assume that the initial velocities of all the particles. It is possible to initialise particles with non-zero velocities. For now, we will stick to zero initial velocities.</p> </li> <li> <p>Define a Python function that takes the input of the number of particles and the limits of the positions to initialise and return a list of objects of class <code>Particle</code>. Each particle has random position within the limits and zero velocity.</p> <pre><code>def initialise_particles(n_ptc, position_limits):\n  # position_limits is a list of two values. The first value is the lower boundary and the second value is the upper boundary.\n  ...\n  return particles\n</code></pre> </li> <li> <p>Remember to test your function before proceed.</p> </li> </ol>"},{"location":"archive/202401/lab4-particle-swarm-optimisation/#update-personal-best","title":"Update personal best","text":"<ol> <li> <p>Create a method in the class <code>Particle</code> to update the <code>best_position</code> if necessary.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(self):\n    # 1. calculate the fitnesses of the best_position and the particle's current position\n    # 2. compare the fitnesses and determine if the current position is better than the best_position\n    # 3. update if necessary\n    # 4. no return statement is required\n</code></pre> </li> <li> <p>If the new position has a lower fitness, i.e. the new position is better than the best position, update the <code>best_position</code> to hold the value of the new position.</p> </li> </ol>"},{"location":"archive/202401/lab4-particle-swarm-optimisation/#update-global-best","title":"Update global best","text":"<ol> <li> <p>Initiate a variable named <code>global_best_position</code> with the value <code>None</code> in the <code>__main__</code> block. </p> </li> <li> <p>Create a function that takes two positions as inputs, compare them, and return the better position of the two.</p> <pre><code>def compareFitness(pos1, pos2):\n  # 1. calculate the fitness of pos1 and pos2\n  # 2. compare to determine the better position\n  return betterpos\n</code></pre> </li> <li> <p>We will later use this function to compare the current global best position with the personal best position of each particle.</p> </li> </ol>"},{"location":"archive/202401/lab4-particle-swarm-optimisation/#update-velocity","title":"Update velocity","text":"<ol> <li> <p>Create a method in the class <code>Particle</code> to update the velocity given \u03b1<sub>1</sub>, \u03b1<sub>2</sub>, \u03b2<sub>1</sub>, \u03b2<sub>2</sub>, and the global best position.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(...):\n    ...\n\n  def update_velocity(self, alpha, beta, glob_best_pos):\n    # alpha is a list of two values. we will access alpha_1 and alpha_2 by alpha[0] and alpha[1] respectively. This also applies to beta.\n    # the current position, current velocity, and personal best position of the particle can be accessed by self.position, self.velocity, and self.best_position\n    # assign the particle's velocity with the updated velocity\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab4-particle-swarm-optimisation/#update-particle-position","title":"Update particle position","text":"<ol> <li> <p>As updating a particle position only require information from within the particle object and the limits of the position, create a method called <code>update_position</code> in the class <code>Particle</code> taking the input of the limits of the position.</p> <pre><code>class Particle:\n  def __init__(...):\n    ...\n\n  def update_personal_best(...):\n    ...\n\n  def update_velocity(...):\n    ...\n\n  def update_position(self, position_limits):\n    self.position = self.position + self.velocity\n    # how should you solve the problem of the position (x) going out of the limits\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab4-particle-swarm-optimisation/#create-a-loop-until-termination","title":"Create a loop (until termination)","text":"<ol> <li> <p>Consider the following termination criteria:</p> <ul> <li>exceeding 200 iterations</li> <li>fitnesses of all particles are close</li> <li>positions of all particles are close</li> </ul> </li> <li> <p>Create a function to calculate the average difference between the mean fitness and the fitness of each particle.</p> <pre><code>def calc_avg_fit_diff(particles):\n  # 1. calculate mean fitness of all particles\n  # 2. calculate the difference between the mean fitness and the fitness of each particle\n  # 3. calculate the average of the differences obtained from step 2\n  return avg_fit_diff\n</code></pre> </li> <li> <p>Create a function to calculate the average difference between the mean position and the position of each particle.</p> <pre><code>def calc_avg_pos_diff(particles):\n  # 1. calculate mean position of all particles\n  # 2. calculate the difference between the mean position and the position of each particle\n  # 3. calculate the average of the differences obtained from step 2\n  return avg_pos_diff\n</code></pre> </li> <li> <p>Create a loop (in the <code>__main__</code> block) to execute the global best particle swarm optimisation (gbest PSO) until termination. </p> <pre><code>if __name__ == '__main__':\n  # parameter initialisation\n  alpha = [0.1, 0.1]\n  n_particle = 10\n  global_best_position = None\n  position_limits = [-100, 100]\n  # termination threshold\n  iteration = 0\n  max_iter = 200\n  min_avg_fit_diff = 0.1\n  min_avg_pos_diff = 0.1\n  # initialise particles\n  particles = initialise_particles(n_particle, position_limits)\n  while (...): # how should you define the termination criteria here?\n    print(iteration, [round(x.position,2) for x in particles])\n    for particle in particles:\n      # update personal best\n      particle.update_personal_best()\n      # update global best\n      if global_best_position == None:\n        global_best_position = particle.position\n      else:\n        global_best_position = compareFitness(global_best_position, particle.position)\n    # generate beta randomly for current iteration\n    beta = [random.random(), random.random()]\n    for particle in particles:\n      # update velocity\n      particle.update_velocity(alpha, beta, global_best_position)\n      # update position\n      particle.update_position(position_limits)\n    iteration += 1\n  # display results\n  print(iteration, [round(x.position,2) for x in particles])\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab4-particle-swarm-optimisation/#visualisation","title":"Visualisation","text":"<ol> <li> <p>Let's add a few lines to visualise particles \"flying\" towards to optimal position.</p> <ul> <li> <p>import the visualisation library   <pre><code>import matplotlib.pyplot as plt\n</code></pre></p> </li> <li> <p>add the following lines just before the <code>while</code> loop in the last code block in the previous section. This is to plot the existing particle positions on the graph.   <pre><code>space_ax = plt.axes()\nspace_ax.plot(list(range(*position_limits)),[fit_fcn(x) for x in range(*position_limits)])\nspace_ax.set_title(\"Position of particles in iteration {}\".format(iteration))\nspace_ax.set_xlabel(\"Position\")\nspace_ax.set_ylabel(\"Fitness\")\n</code></pre></p> </li> <li> <p>add the following lines between line 14 and line 15 in the last code block in the previous section, as well as after line 33. This is to remove the existing particle positions and plot the new positions, i.e to visually update the positions.   <pre><code>if len(space_ax.lines) &gt; 1:\n  space_ax.lines[1].remove()\nspace_ax.plot([x.position for x in particles], [fit_fcn(x.position) for x in particles], 'go')\nspace_ax.set_title(\"Position of particles in iteration {}\".format(iteration))\nplt.pause(0.5) # pause the program for 0.5 second; if graph changes too quickly, increase this value; you can also speed up the process by decreasing this value\n</code></pre></p> </li> </ul> </li> </ol>"},{"location":"archive/202401/lab4-particle-swarm-optimisation/#evaluation","title":"Evaluation","text":"<ol> <li> <p>Store the values of the variables at each iteration for analysis and evaluation.</p> <ul> <li>position of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.position_list = [position]\n\n  def update_position(...):\n    ...\n    self.position_list.append(self.position)\n</code></pre> <ul> <li>velocity of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.velocity_list = [velocity]\n\n  def update_velocity(...):\n    ...\n    self.velocity_list.append(self.velocity)\n</code></pre> <ul> <li>personal best position of each particle at each iteration (add the new line of code to the end of the methods)</li> </ul> <pre><code>class Particle:\n  def __init__(...):\n    ...\n    self.best_position_list = []\n\n  def update_personal_best(...):\n    ...\n    self.best_position_list.append(self.best_position)\n</code></pre> <ul> <li>global best position at each iteration</li> </ul> <pre><code>if __init__ == '__main__':\n  # parameter initialisation\n  ...\n  global_best_position_list = []\n  ...\n        global_best_position = ...\n    global_best_position_list.append(global_best_position) # take note on the indentation\n    # generate beta randomly for current iteration\n    ...\n</code></pre> </li> <li> <p>Visualise the progression of these variables by adding the following code to the end of the <code>__main__</code> block.</p> <pre><code>[pos_fig, position_axes] = plt.subplots(4,1,sharex=True)\nposition_axes[0].set_title(\"Position of each particle\")\nposition_axes[1].set_title(\"Fitness of each particle\")\nposition_axes[2].set_title(\"Boxplot of position at each iteration\")\nposition_axes[3].set_title(\"Boxplot of fitness at each iteration\")\nposition_axes[3].set_xlabel(\"Iteration\")\n\n[vel_fig, velocity_axes] = plt.subplots(2,1,sharex=True)\nvelocity_axes[0].set_title(\"Velocity of each particle\")\nvelocity_axes[1].set_title(\"Boxplot for velocity at each iteration\")\nvelocity_axes[1].set_xlabel(\"Iteration\")\n\n[p_best_fig, personal_best_axes] = plt.subplots(4,1,sharex=True)\npersonal_best_axes[0].set_title(\"Personal best position of each particle\")\npersonal_best_axes[1].set_title(\"Personal best fitness of each particle\")\npersonal_best_axes[2].set_title(\"Boxplot of personal best position at each iteration\")\npersonal_best_axes[3].set_title(\"Boxplot of personal best fitness at each iteration\")\npersonal_best_axes[3].set_xlabel(\"Iteration\")\n\n[g_best_fig, global_best_axes] = plt.subplots(2,1,sharex=True)\nglobal_best_axes[0].set_title(\"Global best position\")\nglobal_best_axes[1].set_title(\"Fitness for global best position\")\nglobal_best_axes[1].set_xlabel(\"Iteration\")\n\nfor particle in particles:\n  iteration_list = list(range(len(particle.position_list)))\n  position_axes[0].plot(iteration_list, particle.position_list, '-o')\n  position_axes[1].plot(iteration_list, [fit_fcn(x) for x in particle.position_list], '-o')\n\n  velocity_axes[0].plot(iteration_list, particle.velocity_list, '-o')\n\n  personal_best_axes[0].plot(iteration_list[:-1], particle.best_position_list, '-o')\n  personal_best_axes[1].plot(iteration_list[:-1], [fit_fcn(x) for x in particle.best_position_list], '-o')\n\nposition_axes[2].boxplot([[p.position_list[i] for p in particles] for i in iteration_list], positions=iteration_list)\nposition_axes[3].boxplot([[fit_fcn(p.position_list[i]) for p in particles] for i in iteration_list], positions=iteration_list)\n\nvelocity_axes[1].boxplot([[p.velocity_list[i] for p in particles] for i in iteration_list], positions=iteration_list)\n\npersonal_best_axes[2].boxplot([[p.best_position_list[i] for p in particles] for i in iteration_list[:-1]], positions=iteration_list[:-1])\npersonal_best_axes[3].boxplot([[fit_fcn(p.best_position_list[i]) for p in particles] for i in iteration_list[:-1]], positions=iteration_list[:-1])\n\nglobal_best_axes[0].plot(iteration_list[:-1], global_best_position_list, '-o')\nglobal_best_axes[1].plot(iteration_list[:-1], [fit_fcn(x) for x in global_best_position_list], '-o')\n</code></pre> </li> </ol>"},{"location":"archive/202401/lab4-particle-swarm-optimisation/#exercise","title":"Exercise","text":"<ol> <li> <p>Multiply the velocity memory, \\(v_i(t)\\), with a value between 0 and 1, let's say 0.5. How does the process change? This is the effect of inertia weight.</p> </li> <li> <p>Reduce the value of \\(\\alpha_1\\) to 0.05 while maintaining \\(\\alpha_2\\) at 0.1 and investigate the effect. </p> </li> <li> <p>Reduce the value of \\(\\alpha_1\\) to 0. How does this affect the result?</p> </li> <li> <p>Modify such that \\(\\alpha_1\\) is larger than \\(\\alpha_2\\). What's the effect?</p> </li> <li> <p>How may you modify the formulae for particles with two variables, in which the fitness function is defined as \\(f(x,y) = x^2 + y^2\\)? </p> </li> </ol>"},{"location":"archive/202401/lab4-particle-swarm-optimisation/#report","title":"Report","text":"<p>Submit a report detailing the process you have gone through and the observations you have made.</p>"},{"location":"archive/202401/lab5-decision-tree/","title":"Lab 5: Decision Tree","text":""},{"location":"archive/202401/lab5-decision-tree/#lab-learning-outcomes","title":"Lab learning outcomes","text":"<p>After completing this lab, the students are able to</p> <ul> <li>construct decision tree using CART learning algorithm with the <code>scikit-learn</code> Python library.</li> </ul>"},{"location":"archive/202401/lab5-decision-tree/#datasets","title":"Datasets","text":"<ol> <li> <p>The iris dataset will be used for classification, and the diabetes dataset for regression.</p> <pre><code>from sklearn import datasets\nimport pandas as pd\niris = datasets.load_iris()\niris = {\n  'attributes': pd.DataFrame(iris.data, columns=iris.feature_names),\n  'target': pd.DataFrame(iris.target, columns=['species']),\n  'targetNames': iris.target_names\n}\ndiabetes = datasets.load_diabetes()\ndiabetes = {\n  'attributes': pd.DataFrame(diabetes.data, columns=diabetes.feature_names),\n  'target': pd.DataFrame(diabetes.target, columns=['diseaseProgression'])\n}\n</code></pre> </li> <li> <p>Split the datasets into 80-20 for train-test proportion.</p> <pre><code>from sklearn.model_selection import train_test_split\nfor dt in [iris, diabetes]:\n  x_train, x_test, y_train, y_test = train_test_split(dt['attributes'], dt['target'], test_size=0.2, random_state=1)\n  dt['train'] = {\n    'attributes': x_train,\n    'target': y_train\n  }\n  dt['test'] = {\n  'attributes': x_test,\n  'target': y_test\n  }\n</code></pre> <p>Note: Be reminded that <code>random_state</code> is used to reproduce the same \"random\" split of the data whenever the function is called. To produce randomly splitted data every time the function is called, remove the <code>random_state</code> argument.</p> </li> </ol> <p>How do we access the training input data for the iris dataset?</p>"},{"location":"archive/202401/lab5-decision-tree/#decision-tree","title":"Decision tree","text":"<p>Decision tree models and algorithms are provided by the <code>scikit-learn</code> as the class <code>sklearn.tree.DecisionTreeClassifier</code> for classification, and <code>sklearn.tree.DecisionTreeRegressor</code> for regression.</p>"},{"location":"archive/202401/lab5-decision-tree/#classification","title":"Classification","text":"<ol> <li> <p>Import the class for decision tree classifier.     <pre><code>from sklearn.tree import DecisionTreeClassifier\n</code></pre></p> </li> <li> <p>Instantiate an object of <code>DecisionTreeClassifier</code> class with gini impurity as the split criterion.     <pre><code>dtc = DecisionTreeClassifier(criterion='gini')\n</code></pre></p> </li> <li> <p>Train the classifier with the training data. We will use all the input attributes.     <pre><code>dtc.fit(iris['train']['attributes'], iris['train']['target'])\n</code></pre></p> </li> <li> <p><code>.predict</code> function is used to predict the species of the testing data.     <pre><code>predicts = dtc.predict(iris['test']['attributes'])\n</code></pre></p> </li> <li> <p>Comparing the predicted value and the target value of the test data.     <pre><code>print(pd.DataFrame(list(zip(iris['test']['target'].species,predicts)), columns=['target', 'predicted']))\n</code></pre></p> </li> <li> <p>Calculate the accuracy of the predicted value.     <pre><code>accuracy = dtc.score(iris['test']['attributes'],iris['test']['target'].species)\nprint(f'Accuracy: {accuracy:.4f}')\n</code></pre></p> </li> <li> <p>Decision tree visualisation</p> <ol> <li> <p>Import the <code>matplotlib.pyplot</code> library and the function to visualise the tree.     <pre><code>import matplotlib.pyplot as plt\nfrom sklearn.tree import plot_tree\n</code></pre></p> </li> <li> <p>Visualise the decision tree model.     <pre><code>plt.figure(figsize=[10,10])\ntree = plot_tree(dtc, feature_names=iris['attributes'].columns.tolist(), \n                 class_names=list(iris['targetNames']), filled=True, rounded=True)\n</code></pre></p> </li> </ol> </li> </ol> <p>The maximum depth of a decision tree can be defined by adding the <code>max_depth=...</code> argument to the <code>DecisionTreeClassifier(...)</code> object instantiation. To allow unlimited maximum depth, pass <code>max_depth=None</code>.</p> <p>Create a loop to compare the accuracy of the prediction with different maximum depths. In every iteration, you should calculate both the accuracy on the training data and the accuracy on the testing data. The comparison should be shown in a graph with <code>max_depth</code> as the horizontal axis and accuracy as the vertical axis. Two lines should be displayed on the graph with one line for training accuracy and the other testing accuracy.</p>"},{"location":"archive/202401/lab5-decision-tree/#visualisation-of-decision-surface","title":"Visualisation of decision surface","text":"<p>This section explains the method to visualise a decision tree on a graph. To do so we will focus on using two input attributes, sepal length and sepal width, i.e. the first two columns.</p> <ol> <li> <p>Instantiate the classifier without defining the maximum depth and train the model.     <pre><code>dtc = DecisionTreeClassifier()\ninput_cols = iris['train']['attributes'].columns[:2].tolist()\ndtc.fit(iris['train']['attributes'][input_cols], iris['train']['target'].species)\n</code></pre></p> </li> <li> <p>Plot the decision tree.     <pre><code>plt.figure(figsize=[50,50])\nplot_tree(dtc, feature_names=input_cols, \n          class_names=list(iris['targetNames']), filled=True, rounded=True)\nplt.savefig('classificationDecisionTreeWithNoMaxDepth.png')\n</code></pre></p> </li> <li> <p>Prepare the colormaps.     <pre><code>from matplotlib import cm\nfrom matplotlib.colors import ListedColormap\ncolormap = cm.get_cmap('tab20')\ncm_dark = ListedColormap(colormap.colors[::2])\ncm_light = ListedColormap(colormap.colors[1::2])\n</code></pre></p> </li> <li> <p>Calculating the decision surface.     <pre><code>import numpy as np\nx_min = iris['attributes'][input_cols[0]].min()\nx_max = iris['attributes'][input_cols[0]].max()\nx_range = x_max - x_min\nx_min = x_min - 0.1 * x_range\nx_max = x_max + 0.1 * x_range\ny_min = iris['attributes'][input_cols[1]].min()\ny_max = iris['attributes'][input_cols[1]].max()\ny_range = y_max - y_min\ny_min = y_min - 0.1 * y_range\ny_max = y_max + 0.1 * y_range\nxx, yy = np.meshgrid(np.arange(x_min, x_max, .01*x_range), \n                    np.arange(y_min, y_max, .01*y_range))\nz = dtc.predict(list(zip(xx.ravel(), yy.ravel())))\nz = z.reshape(xx.shape)\n</code></pre></p> </li> <li> <p>Plot the decision surface.     <pre><code>plt.figure()\nplt.pcolormesh(xx, yy, z, cmap=cm_light)\n</code></pre></p> </li> <li> <p>Plot the training and testing data.     <pre><code>plt.scatter(iris['train']['attributes'][input_cols[0]],   \n            iris['train']['attributes'][input_cols[1]], \n            c=iris['train']['target'].species, cmap=cm_dark, s=200,\n            label='Training data', edgecolor='black', linewidth=1)\nplt.scatter(iris['test']['attributes'][input_cols[0]], \n            iris['test']['attributes'][input_cols[1]], \n            c=iris['test']['target'].species, cmap=cm_dark, s=200,\n            label='Testing data', edgecolor='black', linewidth=1,\n            marker='*')\ntrain_acc = dtc.score(iris['train']['attributes'][input_cols], \n                      iris['train']['target'].species)\ntest_acc = dtc.score(iris['test']['attributes'][input_cols], \n                    iris['test']['target'].species)\nplt.title(f'training: {train_acc:.3f}, testing: {test_acc:.3f}')\nplt.xlabel(input_cols[0])\nplt.ylabel(input_cols[1])\nplt.legend()\n</code></pre></p> </li> </ol> <p>You may not be able to see anything on one of the graph of the decision tree because the figure size is set to be larger than the screen size. However, the tree is saved to a png file in the same folder as your code.</p>"},{"location":"archive/202401/lab5-decision-tree/#overfitting","title":"Overfitting","text":"<p>Now, train a decision tree classifier of <code>max_depth=3</code>with the two input attributes used in the previous section, sepal length and sepal width.</p> <p>Plot the decision surface for this classifier after the training. Compare the decision surface, training accuracy, and testing accuracy between this model and the model in the previous section. </p> <p>Discuss the comparison between the decision tree from previous section and that of <code>max_depth=3</code> from the aspect of overfitting/generalisation.</p>"},{"location":"archive/202401/lab5-decision-tree/#regression","title":"Regression","text":"<p>Regression using decision tree can be achieved by using the <code>DecisionTreeRegressor</code> class in <code>sklearn.tree</code>. Instantiate a regressor class and train the regressor with the training data using all the input attributes.</p> <p>Predict the disease progression of the testing data, and determine the accuracy of the prediction.</p> <p>Create a plot of prediction accuracies against maximum depths of the decision tree for both training data and testing data.</p>"},{"location":"archive/202401/lab5-decision-tree/#visualisation-of-decision-surface_1","title":"Visualisation of decision surface","text":"<p>This section explains the method to visualise a decision tree on a graph. To do so we will focus on using two input attributes, <code>age</code> and <code>bmi</code>.</p> <ol> <li> <p>Instantiate the classifier without defining the maximum depth and train the model.     <pre><code>dtr = DecisiontTreeRegressor()\ninput_cols = ['age', 'bmi']\ndtr.fit(diabetes['train']['attributes'][input_cols], \n        diabetes['train']['target'].diseaseProgression)\n</code></pre></p> </li> <li> <p>Plot the decision tree.     <pre><code>plt.figure(figsize=[50,50])\nplot_tree(dtr, feature_names=input_cols, filled=True, rounded=True)\nplt.savefig('regressionDecisionTreeWithNoMaxDepth.png')\n</code></pre></p> </li> <li> <p>Prepare the colormaps.     <pre><code>from matplotlib import cm\ndia_cm = cm.get_cmap('Reds')\n</code></pre></p> </li> <li> <p>Create the decision surface.     <pre><code>import numpy as np\nx_min = diabetes['attributes'][input_cols[0]].min()\nx_max = diabetes['attributes'][input_cols[0]].max()\nx_range = x_max - x_min\nx_min = x_min - 0.1 * x_range\nx_max = x_max + 0.1 * x_range\ny_min = diabetes['attributes'][input_cols[1]].min()\ny_max = diabetes['attributes'][input_cols[1]].max()\ny_range = y_max - y_min\ny_min = y_min - 0.1 * y_range\ny_max = y_max + 0.1 * y_range\nxx, yy = np.meshgrid(np.arange(x_min, x_max, .01*x_range), \n                    np.arange(y_min, y_max, .01*y_range))\nz = dtr.predict(list(zip(xx.ravel(), yy.ravel())))\nz = z.reshape(xx.shape)\n</code></pre></p> </li> <li> <p>Plot the decision surface     <pre><code>plt.figure()\nplt.pcolormesh(xx, yy, z, cmap=dia_cm)\n</code></pre></p> </li> <li> <p>Plot the training and testing data.     <pre><code>plt.scatter(diabetes['train']['attributes'][input_cols[0]],          \n            diabetes['train']['attributes'][input_cols[1]], \n            c=diabetes['train']['target'].diseaseProgression, \n            label='Training data', cmap=dia_cm, \n            edgecolor='black', linewidth=1, s=150)\nplt.scatter(diabetes['test']['attributes'][input_cols[0]],   \n            diabetes['test']['attributes'][input_cols[1]], \n            c=diabetes['test']['target'].diseaseProgression, marker='*', \n            label='Testing data', cmap=dia_cm, \n            edgecolor='black', linewidth=1, s=150)\nplt.xlabel(input_cols[0])\nplt.ylabel(input_cols[1])\nplt.legend()\nplt.colorbar()\n</code></pre></p> </li> </ol>"},{"location":"archive/202401/lab5-decision-tree/#overfitting_1","title":"Overfitting","text":"<p>Compare the decision tree regressor in the previous model with a decision tree regressor of a small maximum depth and discuss overfitting using the decision surface, training accuracy, and testing accuracy.</p>"},{"location":"archive/202401/lab5-decision-tree/#report","title":"Report","text":"<p>Submit a written report that describes the considerations while writing the scripts, the answers to the above questions, and the problems you encountered in the process. Include your script in the written report as an appendix.</p>"},{"location":"archive/202501/get-start/","title":"Getting started","text":"<p>The labs for ETC2073 Artificial Intelligence will be using Python as the programming language. The Anaconda distribution of Python is recommended, however, if you are familiar and comfortable with the vanilla distribution of Python. For those who have not installed Python in their machine, proceed to next session. This page only covers the installation of the Anaconda platform as, in my opinion, it is more beginner friendly in terms of installing packages and encapsulating environments.</p>"},{"location":"archive/202501/get-start/#installation","title":"Installation","text":"<ol> <li> <p>Download the Anaconda installer with Python 3 for your system from https://www.anaconda.com/download.</p> </li> <li> <p>Use the graphical installer to install Anaconda.</p> </li> </ol>"},{"location":"archive/202501/get-start/#launching-ide","title":"Launching IDE","text":"<p>You will be using the Spyder IDE for Python. Feel free to use other IDE or code editor with terminal if that's your preference.</p> <ol> <li> <p>Start the Anaconda Navigator from your application list.</p> </li> <li> <p>From Anaconda <code>base</code> environment, launch Spyder IDE.</p> </li> <li> <p>The Spyder IDE consists of three parts: the editor, the variable explorer, and the IPython Console.</p> </li> <li> <p>The editor is where you write your codes.</p> </li> <li> <p>The variable explorer shows the value of the variable after running the code.</p> </li> <li> <p>The IPython console allows you to execute commands, interact with the running code, and display visualisation.</p> </li> <li> <p>After the code is written in the editor, you can execute the code using F5 to run file.</p> </li> <li> <p>Then the variables and their values can be found in the variable explorer.</p> </li> </ol>"},{"location":"archive/202501/lab1-introductory-python/","title":"Lab 1: Introduction to Python","text":""},{"location":"archive/202501/lab1-introductory-python/#objective","title":"Objective","text":"<p>To understand basic syntax of Python programming language.</p>"},{"location":"archive/202501/lab1-introductory-python/#declare-a-variable","title":"Declare a variable","text":"<p>Python is strongly and dynamically typed.</p> <p>Strongly typed means the type of a variable does not change unexpectedly. When a variable is defined as a string with only numerical digits, it stays string, it doesn\u2019t become an integer or number.</p> <p>Dynamically typed means the type of a variable can change when a value of a different type is assigned to the variable.</p> <p>As Python is dynamically typed, we do not need to specify a type when we declare a variable. We just assign a value to the variable.</p> <ol> <li> <p>Define a variable named <code>val</code> and assign the value <code>'a'</code> to the variable.</p> <pre><code>val = 'a'\n</code></pre> <p>The type of the variable can be viewed in the variable explorer.</p> </li> <li> <p>Continue from the previous code block, assign the value <code>1</code> to the same variable. The variable will now be of type <code>int</code> instead of type <code>str</code>.</p> <pre><code>val = 1\n</code></pre> </li> </ol>"},{"location":"archive/202501/lab1-introductory-python/#array-manipulation","title":"Array manipulation","text":"<ol> <li> <p>Array in Python can be declared using a set of square brackets (<code>[...]</code>).</p> </li> <li> <p>To assign a variable with an empty array,</p> <pre><code>arr = []\n</code></pre> </li> <li> <p>To define an array with a series of numbers,</p> <pre><code>arr = [1,2,3,4,5]\n</code></pre> </li> <li> <p>To define an array with a series of alphabets,</p> <pre><code>arr = ['a','b','c','d','e']\n</code></pre> </li> <li> <p>An array can also be defined with values of mixed types.</p> <pre><code>arr = [1,'a',2,'b',3,'c']\n</code></pre> </li> <li> <p>Python arrays (or more commonly known as lists) are zero indexed arrays; it means to access the first element in the array <code>arr</code>,</p> <pre><code># in IPython console\narr[0] # gives the output of 1\narr[1] # gives the output of 'a'\n</code></pre> </li> <li> <p>Python arrays also support negative indexing; this means to get the last element in the array <code>arr</code>,</p> <pre><code># in IPython console\narr[-1] # gives the output of 'c'\n</code></pre> </li> <li> <p>Colon (<code>:</code>) can be used to extract multiple elements from an array. Maximum two (2) colons can be used for indexing/slicing an array. <code>arr[0:5:2]</code> The value before the first colon is the starting index, the value after the first colon is the ending index (exclusive), the value after the second colon is the number of steps. </p> <p>If the first value is empty, it is assumed as <code>0</code>.</p> <p>If the second value is empty, it is assumed as the length of the array, i.e. up till the last element in the array.</p> <p>If the third value is empty, it is assumed as <code>1</code>.</p> <pre><code># in IPython console\narr\n# [1, 'a', 2, 'b', 3, 'c']\narr[1:5]\n# ['a', 2, 'b', 3]\narr[1:5:2]\n# ['a', 'b']\narr[:3]\n# [1, 'a', 2]\narr[4:]\n# [3, 'c']\narr[2:-2]\n# [2, 'b']\narr[4:1]\n# []\narr[4:1:-1]\n# [3, 'b', 2] --&gt; slice in the reverse order\n</code></pre> </li> </ol>"},{"location":"archive/202501/lab1-introductory-python/#add-an-element-to-the-end-of-an-array","title":"Add an element to the end of an array","text":"<pre><code># in IPython console\narr.append(4)\narr\n# [1, 'a', 2, 'b', 3, 'c', 4]\n</code></pre>"},{"location":"archive/202501/lab1-introductory-python/#add-multiple-elements-to-the-end-of-an-array","title":"Add multiple elements to the end of an array","text":"<pre><code># in IPython console\narr.extend(['d',5,'e'])\narr\n# [1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n</code></pre>"},{"location":"archive/202501/lab1-introductory-python/#assign-a-value-to-a-specific-index","title":"Assign a value to a specific index","text":"<pre><code># in IPython console\narr[0] = 0\narr\n# [0, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n</code></pre>"},{"location":"archive/202501/lab1-introductory-python/#insert-an-element-at-a-specific-index","title":"Insert an element at a specific index","text":"<pre><code># in IPython console\narr.insert(1,1)\narr\n# [0, 1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n</code></pre>"},{"location":"archive/202501/lab1-introductory-python/#remove-an-element-at-a-specific-index","title":"Remove an element at a specific index","text":"<pre><code># in IPython console\ndel arr[0]\narr\n# [1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n</code></pre>"},{"location":"archive/202501/lab1-introductory-python/#combining-arrays","title":"Combining arrays","text":"<p><code>zip</code> can be used to combine two or more arrays.</p> <pre><code># in editor\njoint_arr = list(zip([1,2,3], ['a','b','c']))\n</code></pre> <pre><code># in IPython console\njoint_arr\n# [(1,'a'),(2,'b'),(3,'c')]\n</code></pre>"},{"location":"archive/202501/lab1-introductory-python/#loops","title":"Loops","text":"<ol> <li> <p>Python supports <code>for</code> and <code>while</code> loops.</p> </li> <li> <p>To loop through every element in the array <code>arr</code> and print them to the console,</p> <pre><code>for a in arr:\n  print(a)\n# 1\n# a\n# 2\n# ...\n</code></pre> <p><code>for a in arr</code>: loops through all elements in <code>arr</code> and in each loop, an element in <code>arr</code> is assigned to the variable <code>a</code>.</p> </li> <li> <p>Note that in most other programming languages, code blocks are separated with delimiters such as the curly brackets (<code>{}</code>). This is not the case in Python. Code blocks in Python are defined by their indentation and normally initiated with a colon(<code>:</code>). </p> <p>For example,</p> <pre><code>for a in arr:\n  print(a)\nprint(arr)\n</code></pre> <p><code>print(a)</code> is the command to be executed in each loop.</p> <p><code>print(arr)</code> is only executed after the <code>for</code> loop is completed.</p> <pre><code>for a in arr:\n  print(a)\n  print(arr)\n</code></pre> <p>In this case, <code>print(arr)</code> is executed in each loop.</p> </li> <li> <p>Using <code>zip</code> we can loop through two arrays at once.</p> <pre><code>for item in zip(['a','b','c','d'],['artificial','breadth','cost','depth']):\n  print(item[0] + ' for ' + item[1])\n</code></pre> </li> <li> <p><code>enumerate</code> is useful in obtaining the index of the element in the array.</p> <pre><code>for (index, item) in enumerate(['a','b','c','d']):\n  print('Index of ' + item + ' is: ' + str(index))\n</code></pre> </li> <li> <p>Looping through a dictionary (<code>dict</code>) can also be done easily.</p> <pre><code>x_dict = {\n  'd': 'depth',\n  'e': 'estimation',\n  'f': 'frontier'\n}\nfor key,value in x_dict.items():\n  print(key + ' for ' + value)\n</code></pre> </li> <li> <p><code>while</code> loops can be defined similarly.</p> <pre><code>x = 0\nwhile x != 10: \n  x += 1\n  print(x)\nprint('while loop is completed')\n</code></pre> </li> <li> <p>The following example introduces nested array and multiple assignments.</p> <pre><code>arr = [['a',1],['b',2],['c',3],['d',4],['e',5],['f',6]]\nfor [a,n] in arr:\n  print(str(a) + ' is ' + str(n))\n</code></pre> </li> </ol>"},{"location":"archive/202501/lab1-introductory-python/#conditions","title":"Conditions","text":"<ol> <li> <p>The following operators can be used for conditional testing:</p> Operator Definition <code>==</code> Equivalence <code>!=</code> Inequivalence <code>&lt;</code> Less than <code>&lt;=</code> Less than or equal to <code>&gt;</code> Greater than <code>&gt;=</code> Greater than or equal to </li> <li> <p>Python also supports text operator for conditional testing:</p> Operator Definition Example (symbolic) Example (text) <code>is</code> Equivalence <code>a == 1</code> <code>a is 1</code> <code>not</code> Inequivalence <code>a != 1</code> <code>a is not 1</code>  or <code>not (a is 1)</code>  or <code>not a is 1</code>  or <code>not(a == 1)</code> </li> <li> <p>Combining two conditions can also be done with text operators <code>and</code> and <code>or</code>.</p> Symbolic operator Text operator <code>&amp;</code> <code>and</code> <code>|</code> <code>or</code> </li> </ol>"},{"location":"archive/202501/lab1-introductory-python/#user-defined-functions","title":"User-defined functions","text":"<ol> <li> <p>To define a custom function with the name of <code>custom_fcn</code>,</p> <pre><code>def custom_fcn():\n  print('This is a custom function to display custom message')\n</code></pre> </li> <li> <p>To call the function,</p> <pre><code>custom_fcn()\n# This is a custom function to display custom message\n</code></pre> </li> </ol>"},{"location":"archive/202501/lab1-introductory-python/#user-defined-functions-with-input-arguments","title":"User-defined functions with input arguments","text":"<ol> <li> <p>To define a custom function with input arguments,</p> <pre><code>def custom_fcn(msg):\n  print('This is a custom function to display ' + msg)\n</code></pre> </li> <li> <p>The function can be called by</p> <pre><code>custom_fcn('new message')\n# This is a custom function to display new message\n</code></pre> </li> </ol>"},{"location":"archive/202501/lab1-introductory-python/#user-defined-functions-with-optional-input-arguments","title":"User-defined functions with optional input arguments","text":"<ol> <li> <p>To define a custom function with optional input arguments, we just need to provide the default value to the optional input arguments.</p> <pre><code>def custom_fcn(msg = 'default message'):\n  print('This is a custom function to display ' + msg)\n</code></pre> </li> <li> <p>The input arguments can also be specified as named inputs.</p> <pre><code>custom_fcn(msg='new message')\n# This is a custom function to display new message\n</code></pre> </li> </ol>"},{"location":"archive/202501/lab1-introductory-python/#exercise","title":"Exercise","text":"<ol> <li> <p>Create a new file in Spyder. Define a variable named <code>friends</code> such that it is a nested array in which contains the name, home country, and home state/province of 10 of your friends (real or virtual). For example,</p> <pre><code>friends = [[\"James\", \"Malaysia\", \"Malacca\"], [\"Goh\", \"Australia\", \"Brisbane\"], [\"Don\", \"Malaysia\", \"Pahang\"]]\n</code></pre> </li> <li> <p>Create a function in the same file with three (3) optional input arguments, <code>name</code>, <code>home_country</code>, <code>home_state</code>.</p> <pre><code>def filterFriend(name=\"\", home_country=\"\", home_state=\"\"):\n  ...\n  return filtered\n</code></pre> <p>This function will filter <code>friends</code> based on the input arguments provided. The function will ignore the input argument if it has empty string, i.e. <code>\"\"</code>. If any of the input arguments is provided, the function will find the friends whose detail(s) matches the input.</p> <p>For example, </p> <p><code>filterFriend(name=\"James\")</code> will return <code>[[\"James\", \"Malaysia\", \"Malacca\"]]</code></p> <p><code>filterFriend(home_country=\"Malaysia\")</code> will return <code>[[\"James\", \"Malaysia\", \"Malacca\"], [\"Don\", \"Malaysia\", \"Pahang\"]]</code>.</p> </li> </ol>"},{"location":"archive/202501/lab2-fuzzy/","title":"Lab 2: Fuzzy Systems","text":""},{"location":"archive/202501/lab2-fuzzy/#lab-learning-outcomes","title":"Lab learning outcomes","text":"<p>After completing this lab, the students are able to</p> <ul> <li>construct a Mamdani fuzzy system using the <code>scikit-fuzzy</code> Python library and</li> <li>evaluate the result of the constructed fuzzy system.</li> </ul>"},{"location":"archive/202501/lab2-fuzzy/#note","title":"Note","text":"<p>Install the <code>scikit-fuzzy</code> Python library in your environment before proceeding with the lab.</p> <pre><code>conda install -c conda-forge scikit-fuzzy\n</code></pre>"},{"location":"archive/202501/lab2-fuzzy/#fuzzy-control-system-for-a-train","title":"Fuzzy control system for a train","text":"<ol> <li> <p>Consider a fuzzy control system to control the brake and throttle of a train based on the speed of the train and the distance of the train to the next stop.</p> </li> <li> <p>Import the <code>skfuzzy</code>, <code>skfuzzy.control</code>, and <code>numpy</code>.</p> <pre><code>import numpy as np\nfrom skfuzzy import control as ctrl\nfrom skfuzzy import membership as mf\n</code></pre> </li> </ol>"},{"location":"archive/202501/lab2-fuzzy/#initialise-inputs-and-outputs","title":"Initialise inputs and outputs","text":"<ol> <li> <p>Speed and distance are the inputs of the system whereas brake and throttle are the outputs.</p> </li> <li> <p>The ranges for the variables are:</p> Variable Range Speed 0 - 85 km/h Distance 0 - 3000 m Brake 0 - 100% Throttle 0 - 100% </li> <li> <p>As the inputs will be the antecedents of the rules, construct the variables <code>speed</code> and <code>distance</code> as <code>skfuzzy.control.Antecedent</code> objects. </p> <pre><code>speed = ctrl.Antecedent(np.arange(0, 85, 0.1), 'speed')\n</code></pre> </li> <li> <p>The initialisation function for <code>skfuzzy.control.Antecedent</code> object takes 2 arguments, the first is the universe of the variable, i.e. the values the variables can take, the second is the label of the variable. The initialisation function for <code>skfuzzy.control.Consequent</code> is similar. </p> </li> <li> <p>The label and the range of the variable can be accessed using <code>.label</code> and <code>.universe</code> respectively.</p> </li> </ol> <p>Task: Initialise the variables <code>distance</code> as <code>Antecedent</code> object, and <code>brake</code> and <code>throttle</code> as <code>Consequent</code> objects. (Outputs of the system will be consequents of the rules)</p>"},{"location":"archive/202501/lab2-fuzzy/#define-membership-functions-for-fuzzy-sets-of-variables","title":"Define membership functions for fuzzy sets of variables","text":"<ol> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>speed (0 to 85 km/h)</p> Linguistic value Fit vector Stopped (1/0, 0/2) Very slow (0/1, 1/2.5, 0/4) Slow (0/2.5, 1/6.5, 0/10.5) Medium fast (0/6.5, 1/26.5, 0/46.5) Fast (0/26.5, 1/70, 1/85) </li> <li> <p>distance (0 to 3000 m)</p> Linguistic value Fit vector At (1/0, 0/2) Very near (0/1, 1/3, 0/5) Near (0/3, 1/101.5, 0/200) Medium far (0/100, 1/1550, 0/3000) Far (0/1500, 1/2250, 1/3000) </li> <li> <p>brake (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/40) Very slight (0/20, 1/50, 0/80) Slight (0/70, 1/83.5, 0/97) Medium (0/95, 1/97, 0/99) Full (0/98, 1/100) </li> <li> <p>throttle (0 to 100%)</p> Linguistic value Fit vector No (1/0, 0/2) Very slight (0/1, 1/3, 0/5) Slight (0/3, 1/16.5, 0/30) Medium (0/20, 1/50, 0/80) Full (0/60, 1/80, 1/100) </li> </ul> </li> <li> <p>The <code>skfuzzy.membership</code> module provides the following membership functions:</p> Membership function Description <code>skfuzzy.membership.dsigmf(x, b1, c1, b2, c2)</code> Difference of two fuzzy sigmoid membership functions <code>skfuzzy.membership.gauss2mf(x, mean1, ...)</code> Gaussian fuzzy membership function of two combined Gaussians <code>skfuzzy.membership.gaussmf(x, mean, sigma)</code> Gaussian fuzzy membership function <code>skfuzzy.membership.gbellmf(x, a, b, c)</code> Generalized Bell function fuzzy membership generator <code>skfuzzy.membership.piecemf(x, abc)</code> Piecewise linear membership function (particularly used in FIRE filters) <code>skfuzzy.membership.pimf(x, a, b, c, d)</code> Pi-function fuzzy membership generator <code>skfuzzy.membership.psigmf(x, b1, c1, b2, c2)</code> Product of two sigmoid membership functions <code>skfuzzy.membership.sigmf(x, b, c)</code> The basic sigmoid membership function generator <code>skfuzzy.membership.smf(x, a, b)</code> S-function fuzzy membership generator <code>skfuzzy.membership.trapmf(x, abcd)</code> Trapezoidal membership function generator <code>skfuzzy.membership.trimf(x, abc)</code> Triangular membership function generator <code>skfuzzy.membership.zmf(x, a, b)</code> Z-function fuzzy membership generator </li> <li> <p>The fit vector of a linguitic value can be assigned to a linguistic variable using</p> <pre><code>speed['stopped'] = mf.trimf(speed.universe, [0, 0, 2])\nspeed['very slow'] = mf.trimf(speed.universe, [1, 2.5, 4])\n</code></pre> <p>Task: Assign all fuzzy sets to the linguistic variables.</p> </li> <li> <p>The fuzzy set diagram of a linguistic variable can be viewed using <code>.view()</code></p> <pre><code>speed.view()\n</code></pre> <p>Task: Check if the fuzzy set diagrams match the fit vectors.</p> </li> </ol>"},{"location":"archive/202501/lab2-fuzzy/#define-rules","title":"Define rules","text":"<ol> <li> <p>The rules for this system are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Distance At Very near Near Medium far Far Speed Stopped Full brakeNo throttle Full brakeVery slight throttle Very slow Full brakeNo throttle Medium brakeVery slight throttle Slight brakeVery slight throttle Slow Full brakeNo throttle Medium brakeVery slight throttle Very slight brakeSlight throttle Medium fast Very slight brakeMedium throttle No brakeFull throttle Fast Very slight brakeMedium throttle No brakeFull throttle </p> </li> <li> <p>Rule can be defined using <code>skfuzzy.control.Rule(antecedent, consequent, label)</code>. To define the first rule, i.e. if distance is 'at' and speed is 'stopped', then full brake and no throttle, </p> <pre><code>rule1 = ctrl.Rule(distance['at'] &amp; speed['stopped'], (brake['full'], throttle['no']))\n</code></pre> <p>If the antecedent consists of multiple parts, they can be combined using operators <code>|</code> (OR), <code>&amp;</code> (AND), and <code>~</code> (NOT).</p> <p>If the consequent consists of multiple parts, they can be combined as a <code>list</code>/<code>tuple</code>.</p> <p>Task: Define all the rules. Then combine all the rules in a <code>list</code>, i.e. <code>rules = [rule1, rule2, ...]</code>.</p> </li> </ol>"},{"location":"archive/202501/lab2-fuzzy/#construct-the-fuzzy-control-system","title":"Construct the fuzzy control system","text":"<ol> <li> <p>The train control system can be constructed with</p> <pre><code>train_ctrl = ctrl.ControlSystem(rules=rules)\n</code></pre> </li> <li> <p>A <code>skfuzzy.control.ControlSystemSimulation</code> object is needed to simulate the control system to obtain the outputs given certain inputs.</p> <pre><code>train = ctrl.ControlSystemSimulation(control_system=train_ctrl)\n</code></pre> </li> <li> <p>To obtain the values for <code>brake</code> and <code>throttle</code> given that <code>speed</code> is 30 km/h and <code>distance</code> is 6 m,</p> <pre><code># define the values for the inputs\ntrain.input['speed'] = 30\ntrain.input['distance'] = 2000\n\n# compute the outputs\ntrain.compute()\n\n# print the output values\nprint(train.output)\n\n# to extract one of the outputs\nprint(train.output['brake'])\n</code></pre> </li> <li> <p>To view the results in the graph,</p> <pre><code>brake.view(sim=train)\nthrottle.view(sim=train)\n</code></pre> </li> </ol>"},{"location":"archive/202501/lab2-fuzzy/#view-the-controloutput-space","title":"View the control/output space","text":"<ol> <li> <p>The control/output space allows us to identify if the outputs fit our expectation.</p> </li> <li> <p>Construct an empty 3D space with 100-by-100 x-y grid.</p> <pre><code>x, y = np.meshgrid(np.linspace(speed.universe.min(), speed.universe.max(), 100),\n                   np.linspace(distance.universe.min(), distance.universe.max(), 100))\nz_brake = np.zeros_like(x, dtype=float)\nz_throttle = np.zeros_like(x, dtype=float)\n</code></pre> </li> <li> <p>Loop through every point and identify the value of brake and throttle of each point. As the specified rules are not exhaustive, i.e. some input combinations do not activate any rule, we will set the output of such input combinations to be <code>float('inf')</code>.     <pre><code>for i,r in enumerate(x):\n  for j,c in enumerate(r):\n    train.input['speed'] = x[i,j]\n    train.input['distance'] = y[i,j]\n    train.compute()\n    try:\n      z_brake[i,j] = train.output['brake']\n      z_throttle[i,j] = train.output['throttle']  \n    except:\n      z_brake[i,j] = float('inf')\n      z_throttle[i,j] = float('inf')\n</code></pre></p> </li> <li> <p>Plot the result in a 3D graph using the <code>matplotlib.pyplot</code> library.</p> <pre><code>import matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef plot3d(x,y,z):\n  fig = plt.figure()\n  ax = fig.add_subplot(111, projection='3d')\n\n  ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='viridis', linewidth=0.4, antialiased=True)\n\n  ax.contourf(x, y, z, zdir='z', offset=-2.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='x', offset=x.max()*1.5, cmap='viridis', alpha=0.5)\n  ax.contourf(x, y, z, zdir='y', offset=y.max()*1.5, cmap='viridis', alpha=0.5)\n\n  ax.view_init(30, 200)\n\nplot3d(x, y, z_brake)\nplot3d(x, y, z_throttle)\n</code></pre> </li> </ol>"},{"location":"archive/202501/lab2-fuzzy/#fuzzy-tipping-recommendation-system","title":"Fuzzy tipping recommendation system","text":"<ol> <li> <p>A fuzzy expert system is designed to identify the percentage of tips a customer will give based on the service and the food the customer received.</p> </li> <li> <p>The system has service rating and food rating as inputs, and tips as output.</p> </li> <li> <p>The fit vectors of the fuzzy sets for the linguistic variables are given as follows:</p> <ul> <li> <p>service (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>food (0 to 10)</p> Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) </li> <li> <p>tips (0 to 30%)</p> Linguistic value Fit vector Low (1/0, 0/15) Medium (0/0, 1/15, 0/30) High (0/15, 1/30) </li> </ul> </li> <li> <p>The rules are displayed in the following fuzzy association memory (FAM) representaion table.</p> <p> Food Poor Average Good Service Poor low tips low tips medium tips Average low tips medium tips high tips Good medium tips high tips high tips </p> </li> </ol> <p>Task: Construct the fuzzy inference system.</p> <p>Task: Discuss, if you were to make at least one modification to the fuzzy tipping recommendation system, what it will be and why.</p>"},{"location":"archive/202501/lab2-fuzzy/#report","title":"Report","text":"<p>Submit a report detailing the process, results, graphs, and your observations.</p>"},{"location":"archive/202501/lab3-genetic-algorithm/","title":"Lab 3: Genetic Algorithm","text":""},{"location":"archive/202501/lab3-genetic-algorithm/#lab-learning-outcomes","title":"Lab learning outcomes","text":"<p>After completing this lab, the students are able to implement genetic algorithm to solve an optimisation problem.</p>"},{"location":"archive/202501/lab3-genetic-algorithm/#binary-to-gray-code-conversion","title":"Binary-to-gray code conversion","text":"<p>Binary string is often used in the implementation of genetic algorithm. However, the downside of using a binary code is that the Hamming distance between two adjacent values is not consistent. This situation is solved by using a Gray code in place of a binary code.</p> <ol> <li> <p><code>numpy</code> provides the function of <code>binary_repr</code> to convert a decimal value to its corresponding binary code.</p> </li> <li> <p>Create a function to take the input of a binary code and return the correponding Gray code of the binary code. </p> </li> <li> <p>Create a function to calculate the Hamming distance between two binary strings (two binary codes or two Gray codes).</p> </li> <li> <p>Consider a sequence of decimal values of <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>. Convert the sequence to a series of binary codes. Identify and plot (example of a line plot) the Hamming distances between the adjacent values.</p> </li> <li> <p>Repeat the previous step with Gray codes instead of binary codes.</p> </li> </ol>"},{"location":"archive/202501/lab3-genetic-algorithm/#genetic-algorithm","title":"Genetic algorithm","text":"<p>Consider the following problem: </p> <p>Problem</p> <p>You are given a sheet of paper with width <code>w</code> and height <code>h</code>. Your task is to cut the paper into squares of equal size. The aim of the task is to have as many squares as possible, and to have the area of each square as large as possible.</p> <ol> <li> <p>An optimisation problem can always be phrased in the form of</p> <p>to optimise ... such that it maximises/minimises ...</p> <p>In this problem, what is the parameter to be optimised and what are the parameters to be maximised or minimised?</p> </li> <li> <p>Let <code>x</code> denotes the length of the sides of a square. We need a fitness function such that higher fitness corresponds to larger number of squares and large area. If the number of squares (that can be cut out) is zero, or the area of the square is zero, the fitness will be zero. Consider the fitness function of <code>number of squares * area of a single square</code>.</p> </li> </ol> feature encoding population initialisation selection as parents crossover mutation offspring (next generation population) repeat from fitnexx calculation until termination"},{"location":"archive/202501/lab3-genetic-algorithm/#feature-encoding","title":"Feature encoding","text":"<ol> <li> <p>In this problem as we only have one feature, i.e. the side length of the square, each chromosome consists of the value of the side length of the square. We will encode the chromosome in the form of Gray code. </p> </li> <li> <p>Create two functions <code>value2gray</code> and <code>gray2value</code> to convert a decimal value to its Gray code and vice versa.</p> <pre><code>def value2gray(value):\n  # this function converts a decimal value to its gray code representation\n  ...\n  return gray\n\ndef gray2value(gray):\n  # this function converts a gray code representation to its decimal value\n  ...\n  return value\n</code></pre> </li> <li> <p>Add the following code snippet to the end of the code to test your functions.</p> <pre><code>if __name__ == \"__main__\":\n  print(value2gray(10))\n  print(gray2value(\"1001\"))\n</code></pre> <p>After running the file as a script, you should see the following output.</p> <pre><code>1111\n14\n</code></pre> </li> </ol>"},{"location":"archive/202501/lab3-genetic-algorithm/#population-initialisation","title":"Population initialisation","text":"<ol> <li> <p>A population is randomly generated according to the defined population size. </p> </li> <li> <p>Create a function to generate randomly a population of size <code>pop_size</code> with each value lies between the range of <code>pop_min</code> to <code>pop_max</code>.</p> <pre><code>def generatePopulation(pop_size, pop_min, pop_max):\n  # this function generate the first generation randomly based on the population size and the range of the value of each chromosome\n  ...\n  return population\n</code></pre> <p>This function and all the functions created after this should be placed before the <code>if __name__ == \"__main__\":</code> code block.</p> </li> <li> <p>[Optional testing] You can test the function by changing the <code>__main__</code> code block to </p> <pre><code>if __name__ == \"__main__\":\n  print(generatePopulation(8, 0, 10))\n</code></pre> <p>The printed output should be a series of 8 chromosomes displayed as decimal values.</p> </li> </ol>"},{"location":"archive/202501/lab3-genetic-algorithm/#fitness-calculation","title":"Fitness calculation","text":"<ol> <li> <p>The fitness function was designed at the beginning of this section. Define a function that takes the input of a chromosome (as decimal value) and returns the fitness of the chromosome.</p> <p><pre><code>def calculateFitness(value):\n  # this function calculates the fitness of a chromosome from the decimal value of the chromosome\n  ...\n  return fitness\n</code></pre> 2. [Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(calculateFitness(5))\n</code></pre> <p>The printed output should be the fitness of a chromosome of value 5, which would be a decimal value larger than zero.</p> </li> </ol>"},{"location":"archive/202501/lab3-genetic-algorithm/#selection-as-parents","title":"Selection as parents","text":"<ol> <li> <p>From the list of the chromosomes, we will select the chromosome pairs as parents. As we will be using one-point crossover, each pair of parents will produce exactly two offsprings. Therefore for population size of <code>pop_size</code>, we need <code>pop_size/2</code> pairs of parents.</p> </li> <li> <p>Define a function that takes the inputs of the current population and the total number of chromosomes in current population, and returns the chromosome pairs which will act as parents. The selection process is performed with the roulette wheel selection. The same chromosome can be selected more than once.</p> <pre><code>def selectParents(chromosomes, pop_size):\n  ...\n  return parent_pairs\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(selectParents([13, 8, 14, 7], 6))\n</code></pre> <p>The printed output should be 3 parent pairs, for example, </p> <pre><code>[[13, 8], [8, 14], [13, 7]]\n</code></pre> </li> </ol>"},{"location":"archive/202501/lab3-genetic-algorithm/#crossover","title":"Crossover","text":"<ol> <li> <p>Define a function that takes a parent pair and returns a pair of offspring after performing one-point crossover.</p> <pre><code>def crossover(parents):\n  # this function takes a parent pair and perform one-point crossover to produce a pair of offspring\n  ...\n  return offsprings\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(crossover([13, 9]))\n</code></pre> <p>The printed output should be a pair of offsprings, for example,</p> <pre><code>[10, 14]\n</code></pre> <p><code>13</code> is <code>1011</code> and <code>9</code> is <code>1101</code> in Gray code, the offsprings <code>10</code> is <code>1111</code> and <code>14</code> is <code>1001</code> in Gray code.</p> </li> </ol>"},{"location":"archive/202501/lab3-genetic-algorithm/#mutation","title":"Mutation","text":"<ol> <li> <p>Each gene in all chromosomes has the same mutation probability <code>p_mutation</code>. </p> </li> <li> <p>Define a function that takes a chromosome and the mutation probability <code>p_mutation</code> as the inputs, and returns the mutated chromosome. </p> <p><pre><code>def mutate(chromosome, p_mutation):\n  # this function mutates each gene of a chromosome based on the mutation probability\n  ...\n  return mutated\n</code></pre> 3. [Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(mutate(15, 0.1))\n</code></pre> <p>The printed output should be the mutated or unmutated chromosome, for example, <code>14</code>.</p> <p><code>15</code> is <code>1000</code> and <code>14</code> is <code>1001</code> in Gray code. In the example output, the last bit is mutated.</p> </li> </ol>"},{"location":"archive/202501/lab3-genetic-algorithm/#repeat-until-termination","title":"Repeat until termination","text":"<ol> <li> <p>The common termination criteria are the maximum number of iterations and the distance among the fitnesses of the chromosomes of the latest population.</p> </li> <li> <p>Define a function that calculates one metric to measure the distance among the fitnesses of the chromosomes, i.e. how far the fitnesses of all the chromosomes are from each other.</p> <pre><code>def findOverallDistance(chromosomes):\n  # this function takes the input of the current population and returns the overall distance among fitnesses of all chromosomes\n  ...\n  return overall_distance\n</code></pre> </li> <li> <p>[Optional] Test the function with</p> <pre><code>if __name__ == \"__main__\":\n  print(findOverallDistance([13, 11, 14, 7]))\n</code></pre> <p>The printed output should be a decimal value that represents the overall distance of fitnesses.</p> </li> </ol>"},{"location":"archive/202501/lab3-genetic-algorithm/#combining-all-functions","title":"Combining all functions","text":"<ol> <li> <p>The functions we have created can be combined with the following code snippet to execute the genetic algorithm to solve the problem defined at the beginning of this section. Consider the width and the height of the sheet of paper to be <code>20cm</code> and <code>15cm</code>.</p> <pre><code>if __name__ == \"__main__\":\n  # main function\n  ## parameter definition\n  pop_size = 10\n  pop_min = 1 #1cm\n  pop_max = 10 #10cm\n  curr_iter = 0\n  max_iter = 100\n  min_overalldistance = 0.5\n  p_mutation = 0.05\n  ## initialise population\n  population = []\n  population.append(generatePopulation(pop_size, pop_min, pop_max))\n  while (curr_iter &lt; max_iter and findOverallDistance(population[-1]) &gt; min_overalldistance):\n    curr_iter += 1\n    ## select parent pairs\n    parents = selectParents(population[-1], len(population[-1]))\n    ## perform crossover\n    offsprings = []\n    for p in parents:\n      new_offsprings = crossover(p)\n      for o in new_offsprings:\n        offsprings.append(o)\n    ## perform mutation\n    mutated = [mutate(offspring, p_mutation) for offspring in offsprings]\n    ## update current population\n    population.append(mutated)\n</code></pre> </li> </ol> <p>Task: Consider a different fitness function than the one defined here. How does it change the outcome of the algorithm?</p>"},{"location":"archive/202501/lab3-genetic-algorithm/#report","title":"Report","text":"<p>Submit a report detailing the process, results, graphs, and your observations.</p>"},{"location":"archive/202501/lab4-decision-tree/","title":"Lab 4: Decision Tree","text":""},{"location":"archive/202501/lab4-decision-tree/#lab-learning-outcomes","title":"Lab learning outcomes","text":"<p>After completing this lab, the students are able to</p> <ul> <li>construct decision tree using CART learning algorithm with the <code>scikit-learn</code> Python library.</li> </ul>"},{"location":"archive/202501/lab4-decision-tree/#datasets","title":"Datasets","text":"<ol> <li> <p>The iris dataset will be used for classification, and the diabetes dataset for regression.</p> <pre><code>from sklearn import datasets\nimport pandas as pd\niris = datasets.load_iris()\niris = {\n  'attributes': pd.DataFrame(iris.data, columns=iris.feature_names),\n  'target': pd.DataFrame(iris.target, columns=['species']),\n  'targetNames': iris.target_names\n}\ndiabetes = datasets.load_diabetes()\ndiabetes = {\n  'attributes': pd.DataFrame(diabetes.data, columns=diabetes.feature_names),\n  'target': pd.DataFrame(diabetes.target, columns=['diseaseProgression'])\n}\n</code></pre> </li> <li> <p>Split the datasets into 80-20 for train-test proportion.</p> <pre><code>from sklearn.model_selection import train_test_split\nfor dt in [iris, diabetes]:\n  x_train, x_test, y_train, y_test = train_test_split(dt['attributes'], dt['target'], test_size=0.2, random_state=1)\n  dt['train'] = {\n    'attributes': x_train,\n    'target': y_train\n  }\n  dt['test'] = {\n  'attributes': x_test,\n  'target': y_test\n  }\n</code></pre> <p>Note: Be reminded that <code>random_state</code> is used to reproduce the same \"random\" split of the data whenever the function is called. To produce randomly splitted data every time the function is called, remove the <code>random_state</code> argument.</p> </li> </ol> <p>How do we access the training input data for the iris dataset?</p>"},{"location":"archive/202501/lab4-decision-tree/#decision-tree","title":"Decision tree","text":"<p>Decision tree models and algorithms are provided by the <code>scikit-learn</code> as the class <code>sklearn.tree.DecisionTreeClassifier</code> for classification, and <code>sklearn.tree.DecisionTreeRegressor</code> for regression.</p>"},{"location":"archive/202501/lab4-decision-tree/#classification","title":"Classification","text":"<ol> <li> <p>Import the class for decision tree classifier.     <pre><code>from sklearn.tree import DecisionTreeClassifier\n</code></pre></p> </li> <li> <p>Instantiate an object of <code>DecisionTreeClassifier</code> class with gini impurity as the split criterion.     <pre><code>dtc = DecisionTreeClassifier(criterion='gini')\n</code></pre></p> </li> <li> <p>Train the classifier with the training data. We will use all the input attributes.     <pre><code>dtc.fit(iris['train']['attributes'], iris['train']['target'])\n</code></pre></p> </li> <li> <p><code>.predict</code> function is used to predict the species of the testing data.     <pre><code>predicts = dtc.predict(iris['test']['attributes'])\n</code></pre></p> </li> <li> <p>Comparing the predicted value and the target value of the test data.     <pre><code>print(pd.DataFrame(list(zip(iris['test']['target'].species,predicts)), columns=['target', 'predicted']))\n</code></pre></p> </li> <li> <p>Calculate the accuracy of the predicted value.     <pre><code>accuracy = dtc.score(iris['test']['attributes'],iris['test']['target'].species)\nprint(f'Accuracy: {accuracy:.4f}')\n</code></pre></p> </li> <li> <p>Decision tree visualisation</p> <ol> <li> <p>Import the <code>matplotlib.pyplot</code> library and the function to visualise the tree.     <pre><code>import matplotlib.pyplot as plt\nfrom sklearn.tree import plot_tree\n</code></pre></p> </li> <li> <p>Visualise the decision tree model.     <pre><code>plt.figure(figsize=[10,10])\ntree = plot_tree(dtc, feature_names=iris['attributes'].columns.tolist(), \n                 class_names=list(iris['targetNames']), filled=True, rounded=True)\n</code></pre></p> </li> </ol> </li> </ol> <p>The maximum depth of a decision tree can be defined by adding the <code>max_depth=...</code> argument to the <code>DecisionTreeClassifier(...)</code> object instantiation. To allow unlimited maximum depth, pass <code>max_depth=None</code>.</p> <p>Create a loop to compare the accuracy of the prediction with different maximum depths. In every iteration, you should calculate both the accuracy on the training data and the accuracy on the testing data. The comparison should be shown in a graph with <code>max_depth</code> as the horizontal axis and accuracy as the vertical axis. Two lines should be displayed on the graph with one line for training accuracy and the other testing accuracy.</p>"},{"location":"archive/202501/lab4-decision-tree/#visualisation-of-decision-surface","title":"Visualisation of decision surface","text":"<p>This section explains the method to visualise a decision tree on a graph. To do so we will focus on using two input attributes, sepal length and sepal width, i.e. the first two columns.</p> <ol> <li> <p>Instantiate the classifier without defining the maximum depth and train the model.     <pre><code>dtc = DecisionTreeClassifier()\ninput_cols = iris['train']['attributes'].columns[:2].tolist()\ndtc.fit(iris['train']['attributes'][input_cols], iris['train']['target'].species)\n</code></pre></p> </li> <li> <p>Plot the decision tree.     <pre><code>plt.figure(figsize=[50,50])\nplot_tree(dtc, feature_names=input_cols, \n          class_names=list(iris['targetNames']), filled=True, rounded=True)\nplt.savefig('classificationDecisionTreeWithNoMaxDepth.png')\n</code></pre></p> </li> <li> <p>Prepare the colormaps.     <pre><code>from matplotlib import cm\nfrom matplotlib.colors import ListedColormap\ncolormap = cm.get_cmap('tab20')\ncm_dark = ListedColormap(colormap.colors[::2])\ncm_light = ListedColormap(colormap.colors[1::2])\n</code></pre></p> </li> <li> <p>Calculating the decision surface.     <pre><code>import numpy as np\nx_min = iris['attributes'][input_cols[0]].min()\nx_max = iris['attributes'][input_cols[0]].max()\nx_range = x_max - x_min\nx_min = x_min - 0.1 * x_range\nx_max = x_max + 0.1 * x_range\ny_min = iris['attributes'][input_cols[1]].min()\ny_max = iris['attributes'][input_cols[1]].max()\ny_range = y_max - y_min\ny_min = y_min - 0.1 * y_range\ny_max = y_max + 0.1 * y_range\nxx, yy = np.meshgrid(np.arange(x_min, x_max, .01*x_range), \n                    np.arange(y_min, y_max, .01*y_range))\nz = dtc.predict(list(zip(xx.ravel(), yy.ravel())))\nz = z.reshape(xx.shape)\n</code></pre></p> </li> <li> <p>Plot the decision surface.     <pre><code>plt.figure()\nplt.pcolormesh(xx, yy, z, cmap=cm_light)\n</code></pre></p> </li> <li> <p>Plot the training and testing data.     <pre><code>plt.scatter(iris['train']['attributes'][input_cols[0]],   \n            iris['train']['attributes'][input_cols[1]], \n            c=iris['train']['target'].species, cmap=cm_dark, s=200,\n            label='Training data', edgecolor='black', linewidth=1)\nplt.scatter(iris['test']['attributes'][input_cols[0]], \n            iris['test']['attributes'][input_cols[1]], \n            c=iris['test']['target'].species, cmap=cm_dark, s=200,\n            label='Testing data', edgecolor='black', linewidth=1,\n            marker='*')\ntrain_acc = dtc.score(iris['train']['attributes'][input_cols], \n                      iris['train']['target'].species)\ntest_acc = dtc.score(iris['test']['attributes'][input_cols], \n                    iris['test']['target'].species)\nplt.title(f'training: {train_acc:.3f}, testing: {test_acc:.3f}')\nplt.xlabel(input_cols[0])\nplt.ylabel(input_cols[1])\nplt.legend()\n</code></pre></p> </li> </ol> <p>You may not be able to see anything on one of the graph of the decision tree because the figure size is set to be larger than the screen size. However, the tree is saved to a png file in the same folder as your code.</p>"},{"location":"archive/202501/lab4-decision-tree/#overfitting","title":"Overfitting","text":"<p>Now, train a decision tree classifier of <code>max_depth=3</code>with the two input attributes used in the previous section, sepal length and sepal width.</p> <p>Plot the decision surface for this classifier after the training. Compare the decision surface, training accuracy, and testing accuracy between this model and the model in the previous section. </p> <p>Discuss the comparison between the decision tree from previous section and that of <code>max_depth=3</code> from the aspect of overfitting/generalisation.</p>"},{"location":"archive/202501/lab4-decision-tree/#regression","title":"Regression","text":"<p>Regression using decision tree can be achieved by using the <code>DecisionTreeRegressor</code> class in <code>sklearn.tree</code>. Instantiate a regressor class and train the regressor with the training data using all the input attributes.</p> <p>Predict the disease progression of the testing data, and determine the accuracy of the prediction.</p> <p>Create a plot of prediction accuracies against maximum depths of the decision tree for both training data and testing data.</p>"},{"location":"archive/202501/lab4-decision-tree/#visualisation-of-decision-surface_1","title":"Visualisation of decision surface","text":"<p>This section explains the method to visualise a decision tree on a graph. To do so we will focus on using two input attributes, <code>age</code> and <code>bmi</code>.</p> <ol> <li> <p>Instantiate the classifier without defining the maximum depth and train the model.     <pre><code>dtr = DecisiontTreeRegressor()\ninput_cols = ['age', 'bmi']\ndtr.fit(diabetes['train']['attributes'][input_cols], \n        diabetes['train']['target'].diseaseProgression)\n</code></pre></p> </li> <li> <p>Plot the decision tree.     <pre><code>plt.figure(figsize=[50,50])\nplot_tree(dtr, feature_names=input_cols, filled=True, rounded=True)\nplt.savefig('regressionDecisionTreeWithNoMaxDepth.png')\n</code></pre></p> </li> <li> <p>Prepare the colormaps.     <pre><code>from matplotlib import cm\ndia_cm = cm.get_cmap('Reds')\n</code></pre></p> </li> <li> <p>Create the decision surface.     <pre><code>import numpy as np\nx_min = diabetes['attributes'][input_cols[0]].min()\nx_max = diabetes['attributes'][input_cols[0]].max()\nx_range = x_max - x_min\nx_min = x_min - 0.1 * x_range\nx_max = x_max + 0.1 * x_range\ny_min = diabetes['attributes'][input_cols[1]].min()\ny_max = diabetes['attributes'][input_cols[1]].max()\ny_range = y_max - y_min\ny_min = y_min - 0.1 * y_range\ny_max = y_max + 0.1 * y_range\nxx, yy = np.meshgrid(np.arange(x_min, x_max, .01*x_range), \n                    np.arange(y_min, y_max, .01*y_range))\nz = dtr.predict(list(zip(xx.ravel(), yy.ravel())))\nz = z.reshape(xx.shape)\n</code></pre></p> </li> <li> <p>Plot the decision surface     <pre><code>plt.figure()\nplt.pcolormesh(xx, yy, z, cmap=dia_cm)\n</code></pre></p> </li> <li> <p>Plot the training and testing data.     <pre><code>plt.scatter(diabetes['train']['attributes'][input_cols[0]],          \n            diabetes['train']['attributes'][input_cols[1]], \n            c=diabetes['train']['target'].diseaseProgression, \n            label='Training data', cmap=dia_cm, \n            edgecolor='black', linewidth=1, s=150)\nplt.scatter(diabetes['test']['attributes'][input_cols[0]],   \n            diabetes['test']['attributes'][input_cols[1]], \n            c=diabetes['test']['target'].diseaseProgression, marker='*', \n            label='Testing data', cmap=dia_cm, \n            edgecolor='black', linewidth=1, s=150)\nplt.xlabel(input_cols[0])\nplt.ylabel(input_cols[1])\nplt.legend()\nplt.colorbar()\n</code></pre></p> </li> </ol>"},{"location":"archive/202501/lab4-decision-tree/#overfitting_1","title":"Overfitting","text":"<p>Compare the decision tree regressor in the previous model with a decision tree regressor of a small maximum depth and discuss overfitting using the decision surface, training accuracy, and testing accuracy.</p>"},{"location":"archive/202501/lab4-decision-tree/#report","title":"Report","text":"<p>Submit a written report that describes the considerations while writing the scripts, the answers to the above questions, and the problems you encountered in the process. Include your script in the written report as an appendix.</p>"}]}