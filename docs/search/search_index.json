{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ETC2073 Artificial Intelligence This site hosts the lab sheets for the module of ETC2073 Artificial Intelligence in the Department of Engineering (DEN) in Sunway University. Aim The aim of these labs is to guide the students to implement the basic artificial intelligence (AI) algorithms with and/or without Python libraries. Information The labs are designed to follow the schedule of the lectures, therefore you will require the knowledge of the previous lectures to be able to conduct the lab. Schedule The schedule is subject to change. Week 1 Getting started Week 1 Pre-lab Week 2 Lab 1 Week 3 Lab 2 Week 4 Lab 3 Week 5 Lab 4 Week 6 Lab 5","title":"Overview"},{"location":"#aim","text":"The aim of these labs is to guide the students to implement the basic artificial intelligence (AI) algorithms with and/or without Python libraries.","title":"Aim"},{"location":"#information","text":"The labs are designed to follow the schedule of the lectures, therefore you will require the knowledge of the previous lectures to be able to conduct the lab.","title":"Information"},{"location":"#schedule","text":"The schedule is subject to change. Week 1 Getting started Week 1 Pre-lab Week 2 Lab 1 Week 3 Lab 2 Week 4 Lab 3 Week 5 Lab 4 Week 6 Lab 5","title":"Schedule"},{"location":"get-start/","text":"Getting started The labs for ETC2073 Artificial Intelligence will be using Python as the programming language. The Anaconda distribution of Python is recommended, however, if you are familiar and comfortable with the vanilla distribution of Python. For those who have not installed Python in their machine, proceed to next session . This page only covers the installation of the Anaconda platform as, in my opinion, it is more beginner friendly in terms of installing packages and encapsulating environments. Installation Download the Anaconda installer with Python 3 for your system from https://www.anaconda.com/distribution/ . Use the graphical installer to install Anaconda. Launching IDE You will be using the Spyder IDE for Python. Feel free to use other IDE or code editor with terminal if that's your preference. Start the Anaconda Navigator from your application list. From Anaconda base environment, launch Spyder IDE. The Spyder IDE consists of three parts: the editor, the variable explorer, and the IPython Console. The editor is where you write your codes. The variable explorer shows the value of the variable after running the code. The IPython console allows you to execute commands, interact with the running code, and display visualisation. After the code is written in the editor, you can execute the code using F5 to run file. Then the variables and their values can be found in the variable explorer.","title":"Getting started"},{"location":"get-start/#getting-started","text":"The labs for ETC2073 Artificial Intelligence will be using Python as the programming language. The Anaconda distribution of Python is recommended, however, if you are familiar and comfortable with the vanilla distribution of Python. For those who have not installed Python in their machine, proceed to next session . This page only covers the installation of the Anaconda platform as, in my opinion, it is more beginner friendly in terms of installing packages and encapsulating environments.","title":"Getting started"},{"location":"get-start/#installation","text":"Download the Anaconda installer with Python 3 for your system from https://www.anaconda.com/distribution/ . Use the graphical installer to install Anaconda.","title":"Installation"},{"location":"get-start/#launching-ide","text":"You will be using the Spyder IDE for Python. Feel free to use other IDE or code editor with terminal if that's your preference. Start the Anaconda Navigator from your application list. From Anaconda base environment, launch Spyder IDE. The Spyder IDE consists of three parts: the editor, the variable explorer, and the IPython Console. The editor is where you write your codes. The variable explorer shows the value of the variable after running the code. The IPython console allows you to execute commands, interact with the running code, and display visualisation. After the code is written in the editor, you can execute the code using F5 to run file. Then the variables and their values can be found in the variable explorer.","title":"Launching IDE"},{"location":"lab1-fuzzy/","text":"Lab 1: Fuzzy Systems Lab learning outcomes After completing this lab, the students are able to construct a Mamdani fuzzy system using the scikit-fuzzy Python library and evaluate the result of the constructed fuzzy system. Note Install the scikit-fuzzy Python library in your environment before proceeding with the lab. conda install - c conda - forge scikit - fuzzy Fuzzy control system for a train Consider a fuzzy control system to control the brake and throttle of a train based on the speed of the train and the distance of the train to the next stop. Import the skfuzzy , skfuzzy.control , and numpy . import numpy as np from skfuzzy import control as ctrl from skfuzzy import membership as mf Initialise inputs and outputs Speed and distance are the inputs of the system whereas brake and throttle are the outputs. The ranges for the variables are: Variable Range Speed 0 - 85 km/h Distance 0 - 3000 m Brake 0 - 100% Throttle 0 - 100% As the inputs will be the antecedents of the rules, construct the variables speed and distance as skfuzzy.control.Antecedent objects. speed = ctrl . Antecedent ( np . arange ( 0 , 85 , 0.1 ), 'speed' ) The initialisation function for skfuzzy.control.Antecedent object takes 2 arguments, the first is the universe of the variable, i.e. the values the variables can take, the second is the label of the variable. The initialisation function for skfuzzy.control.Consequent is similar. The label and the range of the variable can be accessed using .label and .universe respectively. Task : Initialise the variables distance as Antecedent object, and brake and throttle as Consequent objects. (Outputs of the system will be consequents of the rules) Define membership functions for fuzzy sets of variables The fit vectors of the fuzzy sets for the linguistic variables are given as follows: speed (0 to 85 km/h) Linguistic value Fit vector Stopped (1/0, 0/2) Very slow (0/1, 1/2.5, 0/4) Slow (0/2.5, 1/6.5, 0/10.5) Medium fast (0/6.5, 1/26.5, 0/46.5) Fast (0/26.5, 1/70, 1/85) distance (0 to 3000 m) Linguistic value Fit vector At (1/0, 0/2) Very near (0/1, 1/3, 0/5) Near (0/3, 1/101.5, 0/200) Medium far (0/100, 1/1550, 0/3000) Far (0/1500, 1/2250, 1/3000) brake (0 to 100%) Linguistic value Fit vector No (1/0, 0/40) Very slight (0/20, 1/50, 0/80) Slight (0/70, 1/83.5, 0/97) Medium (0/95, 1/97, 0/99) Full (0/98, 1/100) throttle (0 to 100%) Linguistic value Fit vector No (1/0, 0/2) Very slight (0/1, 1/3, 0/5) Slight (0/3, 1/16.5, 0/30) Medium (0/20, 1/50, 0/80) Full (0/60, 1/80, 1/100) The skfuzzy.membership module provides the following membership functions: Membership function Description skfuzzy.membership.dsigmf(x, b1, c1, b2, c2) Difference of two fuzzy sigmoid membership functions skfuzzy.membership.gauss2mf(x, mean1, ...) Gaussian fuzzy membership function of two combined Gaussians skfuzzy.membership.gaussmf(x, mean, sigma) Gaussian fuzzy membership function skfuzzy.membership.gbellmf(x, a, b, c) Generalized Bell function fuzzy membership generator skfuzzy.membership.piecemf(x, abc) Piecewise linear membership function (particularly used in FIRE filters) skfuzzy.membership.pimf(x, a, b, c, d) Pi-function fuzzy membership generator skfuzzy.membership.psigmf(x, b1, c1, b2, c2) Product of two sigmoid membership functions skfuzzy.membership.sigmf(x, b, c) The basic sigmoid membership function generator skfuzzy.membership.smf(x, a, b) S-function fuzzy membership generator skfuzzy.membership.trapmf(x, abcd) Trapezoidal membership function generator skfuzzy.membership.trimf(x, abc) Triangular membership function generator skfuzzy.membership.zmf(x, a, b) Z-function fuzzy membership generator The fit vector of a linguitic value can be assigned to a linguistic variable using speed [ 'stopped' ] = mf . trimf ( speed . universe , [ 0 , 0 , 2 ]) speed [ 'very slow' ] = mf . trimf ( speed . universe , [ 1 , 2.5 , 4 ]) Task : Assign all fuzzy sets to the linguistic variables. The fuzzy set diagram of a linguistic variable can be viewed using .view() speed . view () Task : Check if the fuzzy set diagrams match the fit vectors. Define rules The rules for this system are displayed in the following fuzzy association memory (FAM) representaion table. Distance At Very near Near Medium far Far Speed Stopped Full brake No throttle Full brake Very slight throttle Very slow Full brake No throttle Medium brake Very slight throttle Slight brake Very slight throttle Slow Full brake No throttle Medium brake Very slight throttle Very slight brake Slight throttle Medium fast Very slight brake Medium throttle No brake Full throttle Fast Very slight brake Medium throttle No brake Full throttle Rule can be defined using skfuzzy.control.Rule(antecedent, consequent, label) . To define the first rule, i.e. if distance is 'at' and speed is 'stopped', then full brake and no throttle, rule1 = ctrl . Rule ( distance [ 'at' ] & speed [ 'stopped' ], ( brake [ 'full' ], throttle [ 'no' ])) If the antecedent consists of multiple parts, they can be combined using operators | (OR), & (AND), and ~ (NOT). If the consequent consists of multiple parts, they can be combined as a list / tuple . Task : Define all the rules. Then combine all the rules in a list , i.e. rules = [rule1, rule2, ...] . Construct the fuzzy control system The train control system can be constructed with train_ctrl = ctrl . ControlSystem ( rules = rules ) A skfuzzy.control.ControlSystemSimulation object is needed to simulate the control system to obtain the outputs given certain inputs. train = ctrl . ControlSystemSimulation ( control_system = train_ctrl ) To obtain the values for brake and throttle given that speed is 30 km/h and distance is 6 m, # define the values for the inputs train . input [ 'speed' ] = 30 train . input [ 'distance' ] = 2000 # compute the outputs train . compute () # print the output values print ( train . output ) # to extract one of the outputs print ( train . output [ 'brake' ]) To view the results in the graph, brake . view ( sim = train ) throttle . view ( sim = train ) View the control/output space The control/output space allows us to identify if the outputs fit our expectation. Construct an empty 3D space with 100-by-100 x-y grid. x , y = np . meshgrid ( np . linspace ( speed . universe . min (), speed . universe . max (), 100 ), np . linspace ( distance . universe . min (), distance . universe . max (), 100 )) z_brake = np . zeros_like ( x , dtype = float ) z_throttle = np . zeros_like ( x , dtype = float ) Loop through every point and identify the value of brake and throttle of each point. As the specified rules are not exhaustive, i.e. some input combinations do not activate any rule, we will set the output of such input combinations to be float('inf') . for i , r in enumerate ( x ): for j , c in enumerate ( r ): train . input [ 'speed' ] = x [ i , j ] train . input [ 'distance' ] = y [ i , j ] try : train . compute () except : z_brake [ i , j ] = float ( 'inf' ) z_throttle [ i , j ] = float ( 'inf' ) z_brake [ i , j ] = train . output [ 'brake' ] z_throttle [ i , j ] = train . output [ 'throttle' ] Plot the result in a 3D graph using the matplotlib.pyplot library. import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def plot3d ( x , y , z ): fig = plt . figure () ax = fig . add_subplot ( 111 , projection = '3d' ) ax . plot_surface ( x , y , z , rstride = 1 , cstride = 1 , cmap = 'viridis' , linewidth = 0.4 , antialiased = True ) ax . contourf ( x , y , z , zdir = 'z' , offset =- 2.5 , cmap = 'viridis' , alpha = 0.5 ) ax . contourf ( x , y , z , zdir = 'x' , offset = x . max () * 1.5 , cmap = 'viridis' , alpha = 0.5 ) ax . contourf ( x , y , z , zdir = 'y' , offset = y . max () * 1.5 , cmap = 'viridis' , alpha = 0.5 ) ax . view_init ( 30 , 200 ) plot3d ( x , y , z_brake ) plot3d ( x , y , z_throttle ) Fuzzy tipping recommendation system A fuzzy expert system is designed to identify the percentage of tips a customer will give based on the service and the food the customer received. The system has service rating and food rating as inputs, and tips as output. The fit vectors of the fuzzy sets for the linguistic variables are given as follows: service (0 to 10) Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) food (0 to 10) Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) tips (0 to 30%) Linguistic value Fit vector Low (1/0, 0/15) Medium (0/0, 1/15, 0/30) High (0/15, 1/30) The rules are displayed in the following fuzzy association memory (FAM) representaion table. Food Poor Average Good Service Poor low tips low tips medium tips Average low tips medium tips high tips Good medium tips high tips high tips Task : Construct the fuzzy inference system. Task : Discuss, if you were to make at least one modification to the fuzzy tipping recommendation system, what it will be and why. Report Submit a report detailing the process, results, graphs, and your observations.","title":"Lab 1: Fuzzy Systems"},{"location":"lab1-fuzzy/#lab-1-fuzzy-systems","text":"","title":"Lab 1: Fuzzy Systems"},{"location":"lab1-fuzzy/#lab-learning-outcomes","text":"After completing this lab, the students are able to construct a Mamdani fuzzy system using the scikit-fuzzy Python library and evaluate the result of the constructed fuzzy system.","title":"Lab learning outcomes"},{"location":"lab1-fuzzy/#note","text":"Install the scikit-fuzzy Python library in your environment before proceeding with the lab. conda install - c conda - forge scikit - fuzzy","title":"Note"},{"location":"lab1-fuzzy/#fuzzy-control-system-for-a-train","text":"Consider a fuzzy control system to control the brake and throttle of a train based on the speed of the train and the distance of the train to the next stop. Import the skfuzzy , skfuzzy.control , and numpy . import numpy as np from skfuzzy import control as ctrl from skfuzzy import membership as mf","title":"Fuzzy control system for a train"},{"location":"lab1-fuzzy/#initialise-inputs-and-outputs","text":"Speed and distance are the inputs of the system whereas brake and throttle are the outputs. The ranges for the variables are: Variable Range Speed 0 - 85 km/h Distance 0 - 3000 m Brake 0 - 100% Throttle 0 - 100% As the inputs will be the antecedents of the rules, construct the variables speed and distance as skfuzzy.control.Antecedent objects. speed = ctrl . Antecedent ( np . arange ( 0 , 85 , 0.1 ), 'speed' ) The initialisation function for skfuzzy.control.Antecedent object takes 2 arguments, the first is the universe of the variable, i.e. the values the variables can take, the second is the label of the variable. The initialisation function for skfuzzy.control.Consequent is similar. The label and the range of the variable can be accessed using .label and .universe respectively. Task : Initialise the variables distance as Antecedent object, and brake and throttle as Consequent objects. (Outputs of the system will be consequents of the rules)","title":"Initialise inputs and outputs"},{"location":"lab1-fuzzy/#define-membership-functions-for-fuzzy-sets-of-variables","text":"The fit vectors of the fuzzy sets for the linguistic variables are given as follows: speed (0 to 85 km/h) Linguistic value Fit vector Stopped (1/0, 0/2) Very slow (0/1, 1/2.5, 0/4) Slow (0/2.5, 1/6.5, 0/10.5) Medium fast (0/6.5, 1/26.5, 0/46.5) Fast (0/26.5, 1/70, 1/85) distance (0 to 3000 m) Linguistic value Fit vector At (1/0, 0/2) Very near (0/1, 1/3, 0/5) Near (0/3, 1/101.5, 0/200) Medium far (0/100, 1/1550, 0/3000) Far (0/1500, 1/2250, 1/3000) brake (0 to 100%) Linguistic value Fit vector No (1/0, 0/40) Very slight (0/20, 1/50, 0/80) Slight (0/70, 1/83.5, 0/97) Medium (0/95, 1/97, 0/99) Full (0/98, 1/100) throttle (0 to 100%) Linguistic value Fit vector No (1/0, 0/2) Very slight (0/1, 1/3, 0/5) Slight (0/3, 1/16.5, 0/30) Medium (0/20, 1/50, 0/80) Full (0/60, 1/80, 1/100) The skfuzzy.membership module provides the following membership functions: Membership function Description skfuzzy.membership.dsigmf(x, b1, c1, b2, c2) Difference of two fuzzy sigmoid membership functions skfuzzy.membership.gauss2mf(x, mean1, ...) Gaussian fuzzy membership function of two combined Gaussians skfuzzy.membership.gaussmf(x, mean, sigma) Gaussian fuzzy membership function skfuzzy.membership.gbellmf(x, a, b, c) Generalized Bell function fuzzy membership generator skfuzzy.membership.piecemf(x, abc) Piecewise linear membership function (particularly used in FIRE filters) skfuzzy.membership.pimf(x, a, b, c, d) Pi-function fuzzy membership generator skfuzzy.membership.psigmf(x, b1, c1, b2, c2) Product of two sigmoid membership functions skfuzzy.membership.sigmf(x, b, c) The basic sigmoid membership function generator skfuzzy.membership.smf(x, a, b) S-function fuzzy membership generator skfuzzy.membership.trapmf(x, abcd) Trapezoidal membership function generator skfuzzy.membership.trimf(x, abc) Triangular membership function generator skfuzzy.membership.zmf(x, a, b) Z-function fuzzy membership generator The fit vector of a linguitic value can be assigned to a linguistic variable using speed [ 'stopped' ] = mf . trimf ( speed . universe , [ 0 , 0 , 2 ]) speed [ 'very slow' ] = mf . trimf ( speed . universe , [ 1 , 2.5 , 4 ]) Task : Assign all fuzzy sets to the linguistic variables. The fuzzy set diagram of a linguistic variable can be viewed using .view() speed . view () Task : Check if the fuzzy set diagrams match the fit vectors.","title":"Define membership functions for fuzzy sets of variables"},{"location":"lab1-fuzzy/#define-rules","text":"The rules for this system are displayed in the following fuzzy association memory (FAM) representaion table. Distance At Very near Near Medium far Far Speed Stopped Full brake No throttle Full brake Very slight throttle Very slow Full brake No throttle Medium brake Very slight throttle Slight brake Very slight throttle Slow Full brake No throttle Medium brake Very slight throttle Very slight brake Slight throttle Medium fast Very slight brake Medium throttle No brake Full throttle Fast Very slight brake Medium throttle No brake Full throttle Rule can be defined using skfuzzy.control.Rule(antecedent, consequent, label) . To define the first rule, i.e. if distance is 'at' and speed is 'stopped', then full brake and no throttle, rule1 = ctrl . Rule ( distance [ 'at' ] & speed [ 'stopped' ], ( brake [ 'full' ], throttle [ 'no' ])) If the antecedent consists of multiple parts, they can be combined using operators | (OR), & (AND), and ~ (NOT). If the consequent consists of multiple parts, they can be combined as a list / tuple . Task : Define all the rules. Then combine all the rules in a list , i.e. rules = [rule1, rule2, ...] .","title":"Define rules"},{"location":"lab1-fuzzy/#construct-the-fuzzy-control-system","text":"The train control system can be constructed with train_ctrl = ctrl . ControlSystem ( rules = rules ) A skfuzzy.control.ControlSystemSimulation object is needed to simulate the control system to obtain the outputs given certain inputs. train = ctrl . ControlSystemSimulation ( control_system = train_ctrl ) To obtain the values for brake and throttle given that speed is 30 km/h and distance is 6 m, # define the values for the inputs train . input [ 'speed' ] = 30 train . input [ 'distance' ] = 2000 # compute the outputs train . compute () # print the output values print ( train . output ) # to extract one of the outputs print ( train . output [ 'brake' ]) To view the results in the graph, brake . view ( sim = train ) throttle . view ( sim = train )","title":"Construct the fuzzy control system"},{"location":"lab1-fuzzy/#view-the-controloutput-space","text":"The control/output space allows us to identify if the outputs fit our expectation. Construct an empty 3D space with 100-by-100 x-y grid. x , y = np . meshgrid ( np . linspace ( speed . universe . min (), speed . universe . max (), 100 ), np . linspace ( distance . universe . min (), distance . universe . max (), 100 )) z_brake = np . zeros_like ( x , dtype = float ) z_throttle = np . zeros_like ( x , dtype = float ) Loop through every point and identify the value of brake and throttle of each point. As the specified rules are not exhaustive, i.e. some input combinations do not activate any rule, we will set the output of such input combinations to be float('inf') . for i , r in enumerate ( x ): for j , c in enumerate ( r ): train . input [ 'speed' ] = x [ i , j ] train . input [ 'distance' ] = y [ i , j ] try : train . compute () except : z_brake [ i , j ] = float ( 'inf' ) z_throttle [ i , j ] = float ( 'inf' ) z_brake [ i , j ] = train . output [ 'brake' ] z_throttle [ i , j ] = train . output [ 'throttle' ] Plot the result in a 3D graph using the matplotlib.pyplot library. import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def plot3d ( x , y , z ): fig = plt . figure () ax = fig . add_subplot ( 111 , projection = '3d' ) ax . plot_surface ( x , y , z , rstride = 1 , cstride = 1 , cmap = 'viridis' , linewidth = 0.4 , antialiased = True ) ax . contourf ( x , y , z , zdir = 'z' , offset =- 2.5 , cmap = 'viridis' , alpha = 0.5 ) ax . contourf ( x , y , z , zdir = 'x' , offset = x . max () * 1.5 , cmap = 'viridis' , alpha = 0.5 ) ax . contourf ( x , y , z , zdir = 'y' , offset = y . max () * 1.5 , cmap = 'viridis' , alpha = 0.5 ) ax . view_init ( 30 , 200 ) plot3d ( x , y , z_brake ) plot3d ( x , y , z_throttle )","title":"View the control/output space"},{"location":"lab1-fuzzy/#fuzzy-tipping-recommendation-system","text":"A fuzzy expert system is designed to identify the percentage of tips a customer will give based on the service and the food the customer received. The system has service rating and food rating as inputs, and tips as output. The fit vectors of the fuzzy sets for the linguistic variables are given as follows: service (0 to 10) Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) food (0 to 10) Linguistic value Fit vector Poor (1/0, 0/5) Average (0/0, 1/5, 0/10) Good (0/5, 1/10) tips (0 to 30%) Linguistic value Fit vector Low (1/0, 0/15) Medium (0/0, 1/15, 0/30) High (0/15, 1/30) The rules are displayed in the following fuzzy association memory (FAM) representaion table. Food Poor Average Good Service Poor low tips low tips medium tips Average low tips medium tips high tips Good medium tips high tips high tips Task : Construct the fuzzy inference system. Task : Discuss, if you were to make at least one modification to the fuzzy tipping recommendation system, what it will be and why.","title":"Fuzzy tipping recommendation system"},{"location":"lab1-fuzzy/#report","text":"Submit a report detailing the process, results, graphs, and your observations.","title":"Report"},{"location":"lab2-search/","text":"Lab 2: Breadth-First Search Objective To create Python script to execute breadth first search algorithm. Problem to be solved The search problem we will focus on during this lab is Nick\u2019s route-finding problem in Romania, starting in Arad to reach Bucharest. The road map of Romania, which is the state space of the problem is given as follows: 75 71 151 140 118 111 70 75 120 146 80 99 97 138 101 211 90 85 98 86 142 92 87 Arad Zerind Oradea Sibiu Fagaras Rimnicu Vilcea Pitesti Craiova Drobeta Mehadia Lugoj Timisoara Bucharest Giurgiu Urziceni Hirsova Eforie Vaslui Iasi Neamt new Vue({ el: \"#romania\", data: { circleradius: 10 } }); Translating the state space First we need to define the state space in our problem. The important information from the state space is the connections between states and the step costs between connected states. Notice that in this problem the connections are reversible. Therefore in our state space the connection from Arad to Zerind and the connection from Zerind to Arad are identical, hence only one instance of that connection is needed. The most straightforward way of defining the state space is by using a nested array, in which each inner array consists of the two connected states and its cost. Open a script file and define the variable state_space . The following code shows the first three elements in the nested array. Complete the definition of the variable by referring to the state space provided. state_space = [ [ 'Arad' , 'Zerind' , 75 ], [ 'Arad' , 'Timisoara' , 118 ], [ 'Timisoara' , 'Lugoj' , 111 ], ... ] Define two variables initial_state and goal_state to hold the information from the problem. initial_state = 'Arad' goal_state = 'Bucharest' Actions and transition model Actions and transition model provide us the way to identify the children of a node in a search tree. In this problem, the actions and transition model are straightforward. The actions are limited by the states connected to node and the transition model is directly defined by the action. Therefore we can create a function to search through the state space to find the children of a node, which would be suffice as actions and transition model. To achieve this, we will loop through the state_space to check for any connection linked to the node, the other state on the connection will be the child of the node in the search tree. In the same script file, define the following function: def expandAndReturnChildren ( state_space , node ): children = [] for [ m , n , c ] in state_space : if m == node : children . append ( n ) elif n == node : children . append ( m ) return children This function provides the children of a node given the state_space of the problem. Breadth-first search algorithm Next we will create a function to execute the search algorithm. The first algorithm we will use is the breadth-first search (BFS). As we want to separate the problem definition from the algorithm definition, the algorithm function will have the inputs of the state space, initial state and goal state. def bfs ( state_space , initial_state , goal_state ): In this function, we need two empty arrays to store the frontier and the explored states. def bfs ( state_space , initial_state , goal_state ): frontier = [] explored = [] At initial stage, the initial state is our frontier. def bfs ( state_space , initial_state , goal_state ): frontier = [] explored = [] frontier . append ( initial_state ) When we are generating the search tree, we will continually expanding the first node (FIFO) in the frontier until we generate a node with goal state. Therefore we need to have a loop to repeatedly expanding the first node in the frontier until the goal node is generated. def bfs ( state_space , initial_state , goal_state ): frontier = [] explored = [] found_goal = False frontier . append ( initial_state ) while not found_goal : ... In the loop we will first expand the first node in the frontier to obtain the children, and move the expanded node from frontier to the explored set. while not found_goal : # expand the first in the frontier children = expandAndReturnChildren ( state_space , frontier [ 0 ]) # copy the node to the explored set explored . append ( frontier [ 0 ]) # remove the expanded node from the frontier del frontier [ 0 ] Check if the children generated should be added to the frontier or discarded. If any child is expanded previously, i.e. in the explored set, or if it is generated previously but not expanded yet, i.e. in the frontier, then it should be discarded. Else, it should be added to the frontier. del frontier [ 0 ] # loop through the children for child in children : # check if a node was expanded or generated previously if not ( child in explored ) and not ( child in frontier ): # add child to the frontier frontier . append ( child ) Before a child is added to the frontier, it should be tested for goal. If it has the goal state, the BFS algorithm should in fact be terminated and return the solution. if not ( child in explored ) and not ( child in frontier ): # goal test if child == goal_state : found_goal = True break # add child to the frontiers frontier . append ( child ) Oops, something is not right Now, if you are following, you may notice that we have a way to end the algorithm but we have failed to store our solution. One way to store the solution while generating the search tree is to store the frontier as the paths from the initial state to the leaf nodes instead of just the leaf nodes. Therefore we would be able to retain the memory of the explored section of the search tree. First we need to modify the expandAndReturnChildren function. def expandAndReturnChildren ( state_space , path_to_leaf_node ): children = [] for [ m , n , c ] in state_space : if m == path_to_leaf_node [ - 1 ]: children . append ( path_to_leaf_node + [ n ]) elif n == path_to_leaf_node [ - 1 ]: children . append ( path_to_leaf_node + [ m ]) return children 4. The bfs function is also modified to accommodate to this change. def bfs ( state_space , initial_state , goal_state ): frontier = [] explored = [] found_goal = False solution = [] frontier . append ([ initial_state ]) while not found_goal : # expand the first in the frontier children = expandAndReturnChildren ( state_space , frontier [ 0 ]) # copy the node to the explored set explored . append ( frontier [ 0 ][ - 1 ]) # remove the expanded frontier del frontier [ 0 ] # loop through the children for child in children : # check if a node was expanded or generated previously if not ( child [ - 1 ] in explored ) and not ( child [ - 1 ] in [ f [ - 1 ] for f in frontier ]): # goal test if child [ - 1 ] == goal_state : found_goal = True solution = child # add children to the frontier frontier . append ( child ) print ( \"Explored: \" ) print ( explored ) print ( \"Frontier:\" ) for f in frontier : print ( f ) print ( \"Children: \" ) print ( children ) print ( \"\" ) return solution Noted that in line 12 we are only saving the leaf node that has just been expanded to the explored set since the information of the path is unnecessary to be stored in the explored set. In line 18 , [f[-1] for f in frontier] is used to obtain a list of the leaf nodes in the frontier. This is the pythonic way of extracting from a list to form another list. The one-liner is equivalent to leaf_nodes = [] for f in frontier : leaf_nodes . append ( f [ - 1 ]) f[-1] is used since currently we are saving the path from initial state to the respective leaf node in the frontier. Running the algorithm Now we have two functions expandAndReturnChildren and bfs , alongside with the variables state_space , initial_state , and goal_state . To run a script to execute the bfs function, we can have the script file structured as such: def expandAndReturnChildren ( ... ): ... def bfs ( ... ): ... state_space = [ ... ] initial_state = 'Arad' goal_state = 'Bucharest' print ( 'Solution: ' + str ( bfs ( state_space , initial_state , goal_state ))) Beware that in Python, a .py file can also be used to define a Python library/module. To prevent the commands outside the function to be executed when the file is used as a library instead of a script, we can implement an extra condition check. def expandAndReturnChildren ( ... ): ... def bfs ( ... ): ... if __name__ == '__main__' : state_space = [ ... ] initial_state = 'Arad' goal_state = 'Bucharest' print ( 'Solution: ' + str ( bfs ( state_space , initial_state , goal_state ))) __name__ is a special variable in Python that evaluates to the name of the current module. This variable has the value of '__main__' if it's called as the main program rather than a module or library. This part is essentially the main function in other programming languages like C++ and Java. Compile the program and resolve any error. Redundant storing of states? When you run the script from previous section, you may wonder, if there is a more efficient way of memory usage instead of saving the path to each leaf node in the frontier. Currently there is a lot of redundant states being stored in the variable frontier . Using a class The alternative and more space-efficient way would be to declare each node in the search tree to be an object that stores its name, parent, and children. To do so, we need to first define a class. class Node : def __init__ ( self , state = None , parent = None ): self . state = state self . parent = parent self . children = [] def addChildren ( self , children ): self . children . extend ( children ) In Python, to define a class, the class needs to have the function __init__ with at least one input self . This function is called when an object is initiated with this class. The internal variable self defines the properties of the object. The input arguments apart from self for the function __init__ are the parameters to be passed when initiating a new object. In a class, additional functions can also be defined, and these will be the methods for the object of this class. An example of initiating a new object for this class and use the function is: a_distinct_node = Node ( 'state name' , 'parent of this node' ) a_distinct_node . addChildren ([ 'child 1' , 'child 2' ]) With the new class, we can update the function expandAndReturnChildren to return the children as a list of Node objects. def expandAndReturnChildren ( state_space , node ): children = [] for [ m , n , c ] in state_space : if m == node . state : children . append ( Node ( n , node . state )) elif n == node . state : children . append ( Node ( m , node . state )) return children With the availability of the Node class, we can save the nodes as Node objects in the frontier instead of paths to the leaf nodes. When the goal state is found, the goal node is used to trace back to its predecessor (a.k.a. parent, which will be now in the explored set) which is accessible using the property .parent of the goal node. Then the predecessor to the parent of the goal node can be traced similarly. This process is thus repeated until the initial state (with no parent) to obtain the solution and its cost. def bfs ( state_space , initial_state , goal_state ): frontier = [] explored = [] found_goal = False goalie = Node () solution = [] # add initial state to frontier frontier . append ( Node ( initial_state , None )) while not found_goal : # expand the first in the frontier children = expandAndReturnChildren ( state_space , frontier [ 0 ]) # add children list to the expanded node frontier [ 0 ] . addChildren ( children ) # add to the explored list explored . append ( frontier [ 0 ]) # remove the expanded frontier del frontier [ 0 ] # add children to the frontier for child in children : # check if a node was expanded or generated previously if not ( child . state in [ e . state for e in explored ]) and not ( child . state in [ f . state for f in frontier ]): # goal test if child . state == goal_state : found_goal = True goalie = child frontier . append ( child ) print ( \"Explored:\" , [ e . state for e in explored ]) print ( \"Frontier:\" , [ f . state for f in frontier ]) print ( \"Children:\" , [ c . state for c in children ]) print ( \"\" ) solution = [ goalie . state ] path_cost = 0 while goalie . parent is not None : solution . insert ( 0 , goalie . parent ) for e in explored : if e . state == goalie . parent : path_cost += getCost ( state_space , e . state , goalie . state ) goalie = e break return solution , path_cost def getCost ( state_space , state0 , state1 ): for [ m , n , c ] in state_space : if [ state0 , state1 ] == [ m , n ] or [ state1 , state0 ] == [ m , n ]: return c The compiled program will be structured as such. Compile and run the program. class Node : ... def expandAndReturnChildren ( ... ): ... def bfs ( ... ): ... def getCost ( ... ): ... if __name__ == '__main__' : state_space = [ ... ] initial_state = 'Arad' goal_state = 'Bucharest' [ solution , cost ] = bfs ( state_space , initial_state , goal_state ) print ( \"Solution:\" , solution ) print ( \"Path Cost:\" , cost ) Exercise Fully understand the code as you will have to modify the code for other problem/search algorithms in next labs. How would you modify the code to run other uninformed search algorithms such as uniform-cost search, depth-first search, etc.? Which part(s) of the code do you need to modify? Think about it before you work on that in Lab 3 next week. Submission Submit the final working code using the Node class to MS Teams.","title":"Lab 2: Breadth-First Search"},{"location":"lab2-search/#lab-2-breadth-first-search","text":"","title":"Lab 2: Breadth-First Search"},{"location":"lab2-search/#objective","text":"To create Python script to execute breadth first search algorithm.","title":"Objective"},{"location":"lab2-search/#problem-to-be-solved","text":"The search problem we will focus on during this lab is Nick\u2019s route-finding problem in Romania, starting in Arad to reach Bucharest. The road map of Romania, which is the state space of the problem is given as follows: 75 71 151 140 118 111 70 75 120 146 80 99 97 138 101 211 90 85 98 86 142 92 87 Arad Zerind Oradea Sibiu Fagaras Rimnicu Vilcea Pitesti Craiova Drobeta Mehadia Lugoj Timisoara Bucharest Giurgiu Urziceni Hirsova Eforie Vaslui Iasi Neamt new Vue({ el: \"#romania\", data: { circleradius: 10 } });","title":"Problem to be solved"},{"location":"lab2-search/#translating-the-state-space","text":"First we need to define the state space in our problem. The important information from the state space is the connections between states and the step costs between connected states. Notice that in this problem the connections are reversible. Therefore in our state space the connection from Arad to Zerind and the connection from Zerind to Arad are identical, hence only one instance of that connection is needed. The most straightforward way of defining the state space is by using a nested array, in which each inner array consists of the two connected states and its cost. Open a script file and define the variable state_space . The following code shows the first three elements in the nested array. Complete the definition of the variable by referring to the state space provided. state_space = [ [ 'Arad' , 'Zerind' , 75 ], [ 'Arad' , 'Timisoara' , 118 ], [ 'Timisoara' , 'Lugoj' , 111 ], ... ] Define two variables initial_state and goal_state to hold the information from the problem. initial_state = 'Arad' goal_state = 'Bucharest'","title":"Translating the state space"},{"location":"lab2-search/#actions-and-transition-model","text":"Actions and transition model provide us the way to identify the children of a node in a search tree. In this problem, the actions and transition model are straightforward. The actions are limited by the states connected to node and the transition model is directly defined by the action. Therefore we can create a function to search through the state space to find the children of a node, which would be suffice as actions and transition model. To achieve this, we will loop through the state_space to check for any connection linked to the node, the other state on the connection will be the child of the node in the search tree. In the same script file, define the following function: def expandAndReturnChildren ( state_space , node ): children = [] for [ m , n , c ] in state_space : if m == node : children . append ( n ) elif n == node : children . append ( m ) return children This function provides the children of a node given the state_space of the problem.","title":"Actions and transition model"},{"location":"lab2-search/#breadth-first-search-algorithm","text":"Next we will create a function to execute the search algorithm. The first algorithm we will use is the breadth-first search (BFS). As we want to separate the problem definition from the algorithm definition, the algorithm function will have the inputs of the state space, initial state and goal state. def bfs ( state_space , initial_state , goal_state ): In this function, we need two empty arrays to store the frontier and the explored states. def bfs ( state_space , initial_state , goal_state ): frontier = [] explored = [] At initial stage, the initial state is our frontier. def bfs ( state_space , initial_state , goal_state ): frontier = [] explored = [] frontier . append ( initial_state ) When we are generating the search tree, we will continually expanding the first node (FIFO) in the frontier until we generate a node with goal state. Therefore we need to have a loop to repeatedly expanding the first node in the frontier until the goal node is generated. def bfs ( state_space , initial_state , goal_state ): frontier = [] explored = [] found_goal = False frontier . append ( initial_state ) while not found_goal : ... In the loop we will first expand the first node in the frontier to obtain the children, and move the expanded node from frontier to the explored set. while not found_goal : # expand the first in the frontier children = expandAndReturnChildren ( state_space , frontier [ 0 ]) # copy the node to the explored set explored . append ( frontier [ 0 ]) # remove the expanded node from the frontier del frontier [ 0 ] Check if the children generated should be added to the frontier or discarded. If any child is expanded previously, i.e. in the explored set, or if it is generated previously but not expanded yet, i.e. in the frontier, then it should be discarded. Else, it should be added to the frontier. del frontier [ 0 ] # loop through the children for child in children : # check if a node was expanded or generated previously if not ( child in explored ) and not ( child in frontier ): # add child to the frontier frontier . append ( child ) Before a child is added to the frontier, it should be tested for goal. If it has the goal state, the BFS algorithm should in fact be terminated and return the solution. if not ( child in explored ) and not ( child in frontier ): # goal test if child == goal_state : found_goal = True break # add child to the frontiers frontier . append ( child )","title":"Breadth-first search algorithm"},{"location":"lab2-search/#oops-something-is-not-right","text":"Now, if you are following, you may notice that we have a way to end the algorithm but we have failed to store our solution. One way to store the solution while generating the search tree is to store the frontier as the paths from the initial state to the leaf nodes instead of just the leaf nodes. Therefore we would be able to retain the memory of the explored section of the search tree. First we need to modify the expandAndReturnChildren function. def expandAndReturnChildren ( state_space , path_to_leaf_node ): children = [] for [ m , n , c ] in state_space : if m == path_to_leaf_node [ - 1 ]: children . append ( path_to_leaf_node + [ n ]) elif n == path_to_leaf_node [ - 1 ]: children . append ( path_to_leaf_node + [ m ]) return children 4. The bfs function is also modified to accommodate to this change. def bfs ( state_space , initial_state , goal_state ): frontier = [] explored = [] found_goal = False solution = [] frontier . append ([ initial_state ]) while not found_goal : # expand the first in the frontier children = expandAndReturnChildren ( state_space , frontier [ 0 ]) # copy the node to the explored set explored . append ( frontier [ 0 ][ - 1 ]) # remove the expanded frontier del frontier [ 0 ] # loop through the children for child in children : # check if a node was expanded or generated previously if not ( child [ - 1 ] in explored ) and not ( child [ - 1 ] in [ f [ - 1 ] for f in frontier ]): # goal test if child [ - 1 ] == goal_state : found_goal = True solution = child # add children to the frontier frontier . append ( child ) print ( \"Explored: \" ) print ( explored ) print ( \"Frontier:\" ) for f in frontier : print ( f ) print ( \"Children: \" ) print ( children ) print ( \"\" ) return solution Noted that in line 12 we are only saving the leaf node that has just been expanded to the explored set since the information of the path is unnecessary to be stored in the explored set. In line 18 , [f[-1] for f in frontier] is used to obtain a list of the leaf nodes in the frontier. This is the pythonic way of extracting from a list to form another list. The one-liner is equivalent to leaf_nodes = [] for f in frontier : leaf_nodes . append ( f [ - 1 ]) f[-1] is used since currently we are saving the path from initial state to the respective leaf node in the frontier.","title":"Oops, something is not right"},{"location":"lab2-search/#running-the-algorithm","text":"Now we have two functions expandAndReturnChildren and bfs , alongside with the variables state_space , initial_state , and goal_state . To run a script to execute the bfs function, we can have the script file structured as such: def expandAndReturnChildren ( ... ): ... def bfs ( ... ): ... state_space = [ ... ] initial_state = 'Arad' goal_state = 'Bucharest' print ( 'Solution: ' + str ( bfs ( state_space , initial_state , goal_state ))) Beware that in Python, a .py file can also be used to define a Python library/module. To prevent the commands outside the function to be executed when the file is used as a library instead of a script, we can implement an extra condition check. def expandAndReturnChildren ( ... ): ... def bfs ( ... ): ... if __name__ == '__main__' : state_space = [ ... ] initial_state = 'Arad' goal_state = 'Bucharest' print ( 'Solution: ' + str ( bfs ( state_space , initial_state , goal_state ))) __name__ is a special variable in Python that evaluates to the name of the current module. This variable has the value of '__main__' if it's called as the main program rather than a module or library. This part is essentially the main function in other programming languages like C++ and Java. Compile the program and resolve any error.","title":"Running the algorithm"},{"location":"lab2-search/#redundant-storing-of-states","text":"When you run the script from previous section, you may wonder, if there is a more efficient way of memory usage instead of saving the path to each leaf node in the frontier. Currently there is a lot of redundant states being stored in the variable frontier .","title":"Redundant storing of states?"},{"location":"lab2-search/#using-a-class","text":"The alternative and more space-efficient way would be to declare each node in the search tree to be an object that stores its name, parent, and children. To do so, we need to first define a class. class Node : def __init__ ( self , state = None , parent = None ): self . state = state self . parent = parent self . children = [] def addChildren ( self , children ): self . children . extend ( children ) In Python, to define a class, the class needs to have the function __init__ with at least one input self . This function is called when an object is initiated with this class. The internal variable self defines the properties of the object. The input arguments apart from self for the function __init__ are the parameters to be passed when initiating a new object. In a class, additional functions can also be defined, and these will be the methods for the object of this class. An example of initiating a new object for this class and use the function is: a_distinct_node = Node ( 'state name' , 'parent of this node' ) a_distinct_node . addChildren ([ 'child 1' , 'child 2' ]) With the new class, we can update the function expandAndReturnChildren to return the children as a list of Node objects. def expandAndReturnChildren ( state_space , node ): children = [] for [ m , n , c ] in state_space : if m == node . state : children . append ( Node ( n , node . state )) elif n == node . state : children . append ( Node ( m , node . state )) return children With the availability of the Node class, we can save the nodes as Node objects in the frontier instead of paths to the leaf nodes. When the goal state is found, the goal node is used to trace back to its predecessor (a.k.a. parent, which will be now in the explored set) which is accessible using the property .parent of the goal node. Then the predecessor to the parent of the goal node can be traced similarly. This process is thus repeated until the initial state (with no parent) to obtain the solution and its cost. def bfs ( state_space , initial_state , goal_state ): frontier = [] explored = [] found_goal = False goalie = Node () solution = [] # add initial state to frontier frontier . append ( Node ( initial_state , None )) while not found_goal : # expand the first in the frontier children = expandAndReturnChildren ( state_space , frontier [ 0 ]) # add children list to the expanded node frontier [ 0 ] . addChildren ( children ) # add to the explored list explored . append ( frontier [ 0 ]) # remove the expanded frontier del frontier [ 0 ] # add children to the frontier for child in children : # check if a node was expanded or generated previously if not ( child . state in [ e . state for e in explored ]) and not ( child . state in [ f . state for f in frontier ]): # goal test if child . state == goal_state : found_goal = True goalie = child frontier . append ( child ) print ( \"Explored:\" , [ e . state for e in explored ]) print ( \"Frontier:\" , [ f . state for f in frontier ]) print ( \"Children:\" , [ c . state for c in children ]) print ( \"\" ) solution = [ goalie . state ] path_cost = 0 while goalie . parent is not None : solution . insert ( 0 , goalie . parent ) for e in explored : if e . state == goalie . parent : path_cost += getCost ( state_space , e . state , goalie . state ) goalie = e break return solution , path_cost def getCost ( state_space , state0 , state1 ): for [ m , n , c ] in state_space : if [ state0 , state1 ] == [ m , n ] or [ state1 , state0 ] == [ m , n ]: return c The compiled program will be structured as such. Compile and run the program. class Node : ... def expandAndReturnChildren ( ... ): ... def bfs ( ... ): ... def getCost ( ... ): ... if __name__ == '__main__' : state_space = [ ... ] initial_state = 'Arad' goal_state = 'Bucharest' [ solution , cost ] = bfs ( state_space , initial_state , goal_state ) print ( \"Solution:\" , solution ) print ( \"Path Cost:\" , cost )","title":"Using a class"},{"location":"lab2-search/#exercise","text":"Fully understand the code as you will have to modify the code for other problem/search algorithms in next labs. How would you modify the code to run other uninformed search algorithms such as uniform-cost search, depth-first search, etc.? Which part(s) of the code do you need to modify? Think about it before you work on that in Lab 3 next week.","title":"Exercise"},{"location":"lab2-search/#submission","text":"Submit the final working code using the Node class to MS Teams.","title":"Submission"},{"location":"pre-lab/","text":"Pre-lab: Basic Python Objective To understand basic syntax of Python programming language. Declare a variable Python is strongly and dynamically typed. Strongly typed means the type of a variable does not change unexpectedly. When a variable is defined as a string with only numerical digits, it stays string, it doesn\u2019t become an integer or number. Dynamically typed means the type of a variable can change when a value of a different type is assigned to the variable. As Python is dynamically typed, we do not need to specify a type when we declare a variable. We just assign a value to the variable. Define a variable named val and assign the value 'a' to the variable. val = 'a' The type of the variable can be viewed in the variable explorer. Continue from the previous code block, assign the value 1 to the same variable. The variable will now be of type int instead of type str . val = 1 Array manipulation Array in Python can be declared using a set of square brackets ( [...] ). To assign a variable with an empty array, arr = [] To define an array with a series of numbers, arr = [ 1 , 2 , 3 , 4 , 5 ] To define an array with a series of alphabets, arr = [ 'a' , 'b' , 'c' , 'd' , 'e' ] An array can also be defined with values of mixed types. arr = [ 1 , 'a' , 2 , 'b' , 3 , 'c' ] Python arrays (or more commonly known as lists) are zero indexed arrays; it means to access the first element in the array arr , # in IPython console arr [ 0 ] # gives the output of 1 arr [ 1 ] # gives the output of 'a' Python arrays also support negative indexing; this means to get the last element in the array arr , # in IPython console arr [ - 1 ] # gives the output of 'c' Colon ( : ) can be used to extract multiple elements from an array. Maximum two (2) colons can be used for indexing/slicing an array. arr[0:5:2] The value before the first colon is the starting index, the value after the first colon is the ending index (exclusive), the value after the second colon is the number of steps. If the first value is empty, it is assumed as 0 . If the second value is empty, it is assumed as the length of the array, i.e. up till the last element in the array. If the third value is empty, it is assumed as 1 . # in IPython console arr # [1, 'a', 2, 'b', 3, 'c'] arr [ 1 : 5 ] # ['a', 2, 'b', 3] arr [ 1 : 5 : 2 ] # ['a', 'b'] arr [: 3 ] # [1, 'a', 2] arr [ 4 :] # [3, 'c'] arr [ 2 : - 2 ] # [2, 'b'] arr [ 4 : 1 ] # [] arr [ 4 : 1 : - 1 ] # [3, 'b', 2] --> slice in the reverse order Add an element to the end of an array # in IPython console arr . append ( 4 ) arr # [1, 'a', 2, 'b', 3, 'c', 4] Add multiple elements to the end of an array # in IPython console arr . extend ([ 'd' , 5 , 'e' ]) arr # [1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e'] Assign a value to a specific index # in IPython console arr [ 0 ] = 0 arr # [0, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e'] Insert an element at a specific index # in IPython console arr . insert ( 1 , 1 ) arr # [0, 1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e'] Remove an element at a specific index # in IPython console del arr [ 0 ] arr # [1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e'] Combining arrays zip can be used to combine two or more arrays. # in editor joint_arr = list ( zip ([ 1 , 2 , 3 ], [ 'a' , 'b' , 'c' ])) # in IPython console joint_arr # [(1,'a'),(2,'b'),(3,'c')] Loops Python supports for and while loops. To loop through every element in the array arr and print them to the console, for a in arr : print ( a ) # 1 # a # 2 # ... for a in arr : loops through all elements in arr and in each loop, an element in arr is assigned to the variable a . Note that in most other programming languages, code blocks are separated with delimiters such as the curly brackets ( {} ). This is not the case in Python. Code blocks in Python are defined by their indentation and normally initiated with a colon( : ). For example, for a in arr : print ( a ) print ( arr ) print(a) is the command to be executed in each loop. print(arr) is only executed after the for loop is completed. for a in arr : print ( a ) print ( arr ) In this case, print(arr) is executed in each loop. Using zip we can loop through two arrays at once. for item in zip ([ 'a' , 'b' , 'c' , 'd' ],[ 'artificial' , 'breadth' , 'cost' , 'depth' ]): print ( item [ 0 ] + ' for ' + item [ 1 ]) enumerate is useful in obtaining the index of the element in the array. for ( index , item ) in enumerate ([ 'a' , 'b' , 'c' , 'd' ]): print ( 'Index of ' + item + ' is: ' + str ( index )) Looping through a dictionary ( dict ) can also be done easily. x_dict = { 'd' : 'depth' , 'e' : 'estimation' , 'f' : 'frontier' } for key , value in x_dict . items (): print ( key + ' for ' + value ) while loops can be defined similarly. x = 0 while x != 10 : x += 1 print ( x ) print ( 'while loop is completed' ) The following example introduces nested array and multiple assignments. arr = [[ 'a' , 1 ],[ 'b' , 2 ],[ 'c' , 3 ],[ 'd' , 4 ],[ 'e' , 5 ],[ 'f' , 6 ]] for [ a , n ] in arr : print ( str ( a ) + ' is ' + str ( n )) Conditions The following operators can be used for conditional testing: Operator Definition == Equivalence != Inequivalence < Less than <= Less than or equal to > Greater than >= Greater than or equal to Python also supports text operator for conditional testing: Operator Definition Example (symbolic) Example (text) is Equivalence a == 1 a is 1 not Inequivalence a != 1 a is not 1 or not (a is 1) or not a is 1 or not(a == 1) Combining two conditions can also be done with text operators and and or . Symbolic operator Text operator & and | or User-defined functions To define a custom function with the name of custom_fcn , def custom_fcn (): print ( 'This is a custom function to display custom message' ) To call the function, custom_fcn () # This is a custom function to display custom message User-defined functions with input arguments To define a custom function with input arguments, def custom_fcn ( msg ): print ( 'This is a custom function to display ' + msg ) The function can be called by custom_fcn ( 'new message' ) # This is a custom function to display new message User-defined functions with optional input arguments To define a custom function with optional input arguments, we just need to provide the default value to the optional input arguments. def custom_fcn ( msg = 'default message' ): print ( 'This is a custom function to display ' + msg ) The input arguments can also be specified as named inputs. custom_fcn ( msg = 'new message' ) # This is a custom function to display new message Exercise Create a new file in Spyder. Define a variable named friends such that it is a nested array in which contains the name, home country, and home state/province of 10 of your friends (real or virtual). For example, friends = [[ \"James\" , \"Malaysia\" , \"Malacca\" ], [ \"Goh\" , \"Australia\" , \"Brisbane\" ], [ \"Don\" , \"Malaysia\" , \"Pahang\" ]] Create a function in the same file with three (3) optional input arguments, name , home_country , home_state . def filterFriend ( name = \"\" , home_country = \"\" , home_state = \"\" ): ... return filtered This function will filter friends based on the input arguments provided. The function will ignore the input argument if it has empty string, i.e. \"\" . If any of the input arguments is provided, the function will find the friends whose detail(s) matches the input. For example, filterFriend(name=\"James\") will return [[\"James\", \"Malaysia\", \"Malacca\"]] filterFriend(home_country=\"Malaysia\") will return [[\"James\", \"Malaysia\", \"Malacca\"], [\"Don\", \"Malaysia\", \"Pahang\"]] .","title":"Pre-lab: Basic Python"},{"location":"pre-lab/#pre-lab-basic-python","text":"","title":"Pre-lab: Basic Python"},{"location":"pre-lab/#objective","text":"To understand basic syntax of Python programming language.","title":"Objective"},{"location":"pre-lab/#declare-a-variable","text":"Python is strongly and dynamically typed. Strongly typed means the type of a variable does not change unexpectedly. When a variable is defined as a string with only numerical digits, it stays string, it doesn\u2019t become an integer or number. Dynamically typed means the type of a variable can change when a value of a different type is assigned to the variable. As Python is dynamically typed, we do not need to specify a type when we declare a variable. We just assign a value to the variable. Define a variable named val and assign the value 'a' to the variable. val = 'a' The type of the variable can be viewed in the variable explorer. Continue from the previous code block, assign the value 1 to the same variable. The variable will now be of type int instead of type str . val = 1","title":"Declare a variable"},{"location":"pre-lab/#array-manipulation","text":"Array in Python can be declared using a set of square brackets ( [...] ). To assign a variable with an empty array, arr = [] To define an array with a series of numbers, arr = [ 1 , 2 , 3 , 4 , 5 ] To define an array with a series of alphabets, arr = [ 'a' , 'b' , 'c' , 'd' , 'e' ] An array can also be defined with values of mixed types. arr = [ 1 , 'a' , 2 , 'b' , 3 , 'c' ] Python arrays (or more commonly known as lists) are zero indexed arrays; it means to access the first element in the array arr , # in IPython console arr [ 0 ] # gives the output of 1 arr [ 1 ] # gives the output of 'a' Python arrays also support negative indexing; this means to get the last element in the array arr , # in IPython console arr [ - 1 ] # gives the output of 'c' Colon ( : ) can be used to extract multiple elements from an array. Maximum two (2) colons can be used for indexing/slicing an array. arr[0:5:2] The value before the first colon is the starting index, the value after the first colon is the ending index (exclusive), the value after the second colon is the number of steps. If the first value is empty, it is assumed as 0 . If the second value is empty, it is assumed as the length of the array, i.e. up till the last element in the array. If the third value is empty, it is assumed as 1 . # in IPython console arr # [1, 'a', 2, 'b', 3, 'c'] arr [ 1 : 5 ] # ['a', 2, 'b', 3] arr [ 1 : 5 : 2 ] # ['a', 'b'] arr [: 3 ] # [1, 'a', 2] arr [ 4 :] # [3, 'c'] arr [ 2 : - 2 ] # [2, 'b'] arr [ 4 : 1 ] # [] arr [ 4 : 1 : - 1 ] # [3, 'b', 2] --> slice in the reverse order","title":"Array manipulation"},{"location":"pre-lab/#add-an-element-to-the-end-of-an-array","text":"# in IPython console arr . append ( 4 ) arr # [1, 'a', 2, 'b', 3, 'c', 4]","title":"Add an element to the end of an array"},{"location":"pre-lab/#add-multiple-elements-to-the-end-of-an-array","text":"# in IPython console arr . extend ([ 'd' , 5 , 'e' ]) arr # [1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']","title":"Add multiple elements to the end of an array"},{"location":"pre-lab/#assign-a-value-to-a-specific-index","text":"# in IPython console arr [ 0 ] = 0 arr # [0, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']","title":"Assign a value to a specific index"},{"location":"pre-lab/#insert-an-element-at-a-specific-index","text":"# in IPython console arr . insert ( 1 , 1 ) arr # [0, 1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']","title":"Insert an element at a specific index"},{"location":"pre-lab/#remove-an-element-at-a-specific-index","text":"# in IPython console del arr [ 0 ] arr # [1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']","title":"Remove an element at a specific index"},{"location":"pre-lab/#combining-arrays","text":"zip can be used to combine two or more arrays. # in editor joint_arr = list ( zip ([ 1 , 2 , 3 ], [ 'a' , 'b' , 'c' ])) # in IPython console joint_arr # [(1,'a'),(2,'b'),(3,'c')]","title":"Combining arrays"},{"location":"pre-lab/#loops","text":"Python supports for and while loops. To loop through every element in the array arr and print them to the console, for a in arr : print ( a ) # 1 # a # 2 # ... for a in arr : loops through all elements in arr and in each loop, an element in arr is assigned to the variable a . Note that in most other programming languages, code blocks are separated with delimiters such as the curly brackets ( {} ). This is not the case in Python. Code blocks in Python are defined by their indentation and normally initiated with a colon( : ). For example, for a in arr : print ( a ) print ( arr ) print(a) is the command to be executed in each loop. print(arr) is only executed after the for loop is completed. for a in arr : print ( a ) print ( arr ) In this case, print(arr) is executed in each loop. Using zip we can loop through two arrays at once. for item in zip ([ 'a' , 'b' , 'c' , 'd' ],[ 'artificial' , 'breadth' , 'cost' , 'depth' ]): print ( item [ 0 ] + ' for ' + item [ 1 ]) enumerate is useful in obtaining the index of the element in the array. for ( index , item ) in enumerate ([ 'a' , 'b' , 'c' , 'd' ]): print ( 'Index of ' + item + ' is: ' + str ( index )) Looping through a dictionary ( dict ) can also be done easily. x_dict = { 'd' : 'depth' , 'e' : 'estimation' , 'f' : 'frontier' } for key , value in x_dict . items (): print ( key + ' for ' + value ) while loops can be defined similarly. x = 0 while x != 10 : x += 1 print ( x ) print ( 'while loop is completed' ) The following example introduces nested array and multiple assignments. arr = [[ 'a' , 1 ],[ 'b' , 2 ],[ 'c' , 3 ],[ 'd' , 4 ],[ 'e' , 5 ],[ 'f' , 6 ]] for [ a , n ] in arr : print ( str ( a ) + ' is ' + str ( n ))","title":"Loops"},{"location":"pre-lab/#conditions","text":"The following operators can be used for conditional testing: Operator Definition == Equivalence != Inequivalence < Less than <= Less than or equal to > Greater than >= Greater than or equal to Python also supports text operator for conditional testing: Operator Definition Example (symbolic) Example (text) is Equivalence a == 1 a is 1 not Inequivalence a != 1 a is not 1 or not (a is 1) or not a is 1 or not(a == 1) Combining two conditions can also be done with text operators and and or . Symbolic operator Text operator & and | or","title":"Conditions"},{"location":"pre-lab/#user-defined-functions","text":"To define a custom function with the name of custom_fcn , def custom_fcn (): print ( 'This is a custom function to display custom message' ) To call the function, custom_fcn () # This is a custom function to display custom message","title":"User-defined functions"},{"location":"pre-lab/#user-defined-functions-with-input-arguments","text":"To define a custom function with input arguments, def custom_fcn ( msg ): print ( 'This is a custom function to display ' + msg ) The function can be called by custom_fcn ( 'new message' ) # This is a custom function to display new message","title":"User-defined functions with input arguments"},{"location":"pre-lab/#user-defined-functions-with-optional-input-arguments","text":"To define a custom function with optional input arguments, we just need to provide the default value to the optional input arguments. def custom_fcn ( msg = 'default message' ): print ( 'This is a custom function to display ' + msg ) The input arguments can also be specified as named inputs. custom_fcn ( msg = 'new message' ) # This is a custom function to display new message","title":"User-defined functions with optional input arguments"},{"location":"pre-lab/#exercise","text":"Create a new file in Spyder. Define a variable named friends such that it is a nested array in which contains the name, home country, and home state/province of 10 of your friends (real or virtual). For example, friends = [[ \"James\" , \"Malaysia\" , \"Malacca\" ], [ \"Goh\" , \"Australia\" , \"Brisbane\" ], [ \"Don\" , \"Malaysia\" , \"Pahang\" ]] Create a function in the same file with three (3) optional input arguments, name , home_country , home_state . def filterFriend ( name = \"\" , home_country = \"\" , home_state = \"\" ): ... return filtered This function will filter friends based on the input arguments provided. The function will ignore the input argument if it has empty string, i.e. \"\" . If any of the input arguments is provided, the function will find the friends whose detail(s) matches the input. For example, filterFriend(name=\"James\") will return [[\"James\", \"Malaysia\", \"Malacca\"]] filterFriend(home_country=\"Malaysia\") will return [[\"James\", \"Malaysia\", \"Malacca\"], [\"Don\", \"Malaysia\", \"Pahang\"]] .","title":"Exercise"}]}